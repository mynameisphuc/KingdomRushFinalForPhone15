<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kingdom JS - TD (Strategic Reinforcements)</title>
    <style>
        :root { 
            --primary: #f1c40f; 
            --danger: #e74c3c; 
            --bg: #2c3e50; 
            --skill-bg: rgba(44, 62, 80, 0.9); 
            --hero-color: #9b59b6;
            --panel-bg: #8d6e63;
        }
        body { margin: 0; padding: 0; background: var(--bg); font-family: 'Segoe UI', sans-serif; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; color: white; user-select: none; }
        #game-container { position: relative; box-shadow: 0 0 50px rgba(0,0,0,0.5); border: 4px solid #3e2723; border-radius: 8px; overflow: hidden; background: #27ae60; }
        canvas { display: block; background: transparent; transition: transform 0.05s; }
        canvas.skill-mode { cursor: crosshair; }
        
        .ui-panel { position: absolute; top: 10px; left: 10px; pointer-events: none; text-shadow: 2px 2px 2px black; z-index: 10; }
        .stat { font-size: 20px; font-weight: bold; margin-bottom: 5px; display: flex; align-items: center; }
        .stat span { color: var(--primary); margin-left: 8px; }
        
        #top-controls { position: absolute; top: 15px; right: 15px; display: flex; gap: 10px; z-index: 100; }
        .control-btn {
            padding: 10px 15px; background: #5d4037; border: 2px solid #fff; border-radius: 8px;
            color: white; font-weight: bold; cursor: pointer; box-shadow: 0 4px 0 #3e2723; transition: 0.1s;
        }
        .control-btn:hover { background: #d4af37; color: #000; transform: translateY(-2px); }
        .control-btn:active { transform: translateY(2px); box-shadow: none; }
        #speed-btn { background: #3498db; min-width: 80px; }
        #wave-btn { background: var(--danger); box-shadow: 0 4px 0 #c0392b; min-width: 140px; text-align: center; }

        #skills-bar { position: absolute; bottom: 15px; left: 15px; display: flex; gap: 10px; pointer-events: auto; z-index: 10; align-items: center; }
        .skill-btn { 
            width: 60px; height: 60px; background: var(--skill-bg); border: 3px solid #5d4037; 
            border-radius: 8px; cursor: pointer; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; font-size: 24px; position: relative;
        }
        .skill-btn:hover { border-color: var(--primary); transform: scale(1.05); }
        .skill-btn.active { border-color: #3498db; box-shadow: 0 0 15px #3498db; }
        .skill-btn .hotkey { position: absolute; top: -8px; right: -8px; background: #222; font-size: 10px; padding: 2px 5px; border-radius: 4px; border: 1px solid #555; }
        .skill-btn .cooldown-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0,0,0,0.6); transition: height 0.1s linear; pointer-events: none; }

        #skill-cancel {
            width: 35px; height: 35px; background: #e74c3c; border: 2px solid white; border-radius: 50%;
            cursor: pointer; display: none; align-items: center; justify-content: center;
            font-weight: bold; font-size: 16px; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            transition: 0.2s; color: white;
        }
        #skill-cancel:hover { background: #ff4d4d; transform: scale(1.1); }

        #build-menu, #upgrade-menu { 
            position: absolute; display: none; background: rgba(62, 39, 35, 0.9); 
            border-radius: 50%; width: 140px; height: 140px; transform: translate(-50%, -50%);
            border: 4px solid #d4af37; z-index: 200;
        }
        .menu-btn {
            position: absolute; width: 50px; height: 50px; border-radius: 50%;
            border: 2px solid #fff; cursor: pointer; display: flex; 
            flex-direction: column; align-items: center; justify-content: center;
            font-size: 11px; color: white; font-weight: bold; transition: 0.2s;
            background: #5d4037; box-shadow: 0 4px 0 #3e2723;
        }
        .menu-btn:hover { background: #d4af37; color: black; transform: scale(1.1); }
        .menu-btn.disabled { opacity: 0.4; filter: grayscale(1); pointer-events: none; }
        
        .btn-archer { top: -20px; left: 45px; }
        .btn-mage { top: 45px; right: -20px; }
        .btn-barracks { bottom: -20px; left: 45px; }
        .btn-artillery { top: 45px; left: -20px; }

        .btn-upgrade { top: -20px; left: 45px; }
        .btn-sell { bottom: -20px; left: 45px; background: #e74c3c !important; }
        .btn-rally { top: 45px; right: -20px; background: #3498db !important; }
        
        #upg-spec-1-btn { top: -20px; left: 10px; background: #3498db !important; }
        #upg-spec-2-btn { top: -20px; left: 80px; background: #e67e22 !important; }

        /* Tutorial Arrow Styles */
        #tutorial-arrow-dom {
            position: absolute; width: 0; height: 0;
            border-left: 15px solid transparent; border-right: 15px solid transparent;
            border-top: 30px solid #e74c3c;
            z-index: 1000; pointer-events: none; display: none;
            filter: drop-shadow(0 0 5px white);
            animation: arrowBounce 0.5s infinite alternate;
        }
        #tutorial-arrow-dom.point-left {
            border-top: 15px solid transparent; border-bottom: 15px solid transparent;
            border-right: 30px solid #e74c3c; /* Tip points left */
            animation: arrowBounceLeft 0.5s infinite alternate;
        }
        @keyframes arrowBounce { from { transform: translateY(0); } to { transform: translateY(-15px); } }
        @keyframes arrowBounceLeft { from { transform: translateX(0); } to { transform: translateX(15px); } }
        #tutorial-overlay {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(62, 39, 35, 0.95); padding: 20px 30px; border-radius: 12px;
            border: 3px solid var(--primary); z-index: 400; width: 450px; text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8); display: none;
        }
        #tutorial-msg { font-size: 16px; line-height: 1.5; margin-bottom: 15px; color: #fff; }
        .tutorial-btn { padding: 8px 20px; background: var(--primary); border: none; border-radius: 5px; color: #000; font-weight: bold; cursor: pointer; }

        #msg-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 300; text-align: center; }
        #pause-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.6); padding: 20px 40px; border-radius: 10px; border: 2px solid white; display: none; font-size: 32px; font-weight: bold; z-index: 250; pointer-events: none; }

        #hero-status { position: absolute; bottom: 15px; right: 15px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; border: 2px solid var(--hero-color); pointer-events: none; display: flex; align-items: center; gap: 10px; z-index: 10; }
        .hero-lvl-badge { background: var(--primary); color: #000; font-size: 10px; padding: 2px 4px; border-radius: 4px; font-weight: bold; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <!-- High-level HTML Arrow -->
    <div id="tutorial-arrow-dom"></div>

    <div id="tutorial-overlay">
        <div id="tutorial-msg">Ch√†o m·ª´ng B·ªá h·∫°! H√£y chu·∫©n b·ªã ph√≤ng th·ªß.</div>
        <button class="tutorial-btn" id="tutorial-next" onclick="game.advanceTutorial()">TI·∫æP T·ª§C</button>
        <button class="tutorial-btn" style="background: #7f8c8d; margin-left: 10px;" onclick="game.skipTutorial()">B·ªé QUA</button>
    </div>

    <div id="instruction-text" style="position: absolute; top: 85px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 8px 20px; border-radius: 20px; display: none; color: #fff; border: 1px solid var(--primary); font-weight: bold; z-index: 300;">CH·ªåN V·ªä TR√ç</div>
    <div id="pause-indicator">T·∫†M D·ª™NG</div>

    <div id="top-controls">
        <button class="control-btn" onclick="window.location.href='menu.html'">üè† MENU</button>
        <button id="speed-btn" class="control-btn" onclick="game.toggleSpeed()">‚è© 1x</button>
        <button id="wave-btn" class="control-btn" onclick="game.nextWave()">B·∫ÆT ƒê·∫¶U WAVE<br><small id="wave-bonus-text"></small></button>
        <button id="restart-btn" class="control-btn" onclick="game.restart()">üîÑ CH∆†I L·∫†I</button>
    </div>

    <div class="ui-panel">
        <div class="stat">V√ÄNG: <span id="gold-val">250</span></div>
        <div class="stat">M·∫†NG: <span id="lives-val">20</span></div>
        <div class="stat">WAVE: <span id="wave-val">0/12</span></div>
    </div>

    <div id="skills-bar">
        <div id="skill-rain" class="skill-btn" onclick="game.selectSkill('RAIN')">
            <span class="hotkey">Q</span>
            üî•<div class="cooldown-overlay" id="cd-rain"></div>
        </div>
        <div id="skill-reinforce" class="skill-btn" onclick="game.selectSkill('REINFORCE')">
            <span class="hotkey">W</span>
            ‚öîÔ∏è<div class="cooldown-overlay" id="cd-reinforce"></div>
        </div>
        <div id="skill-hero" class="skill-btn" onclick="game.useHeroSkill()">
            <span class="hotkey">E</span>
            ‚ö°<div class="cooldown-overlay" id="cd-hero"></div>
        </div>
        <div id="skill-move" class="skill-btn" onclick="game.selectHeroMove()">
            <span class="hotkey">R</span>
            üëü<div class="cooldown-overlay" id="cd-move"></div>
        </div>
        <div id="skill-cancel" title="H·ªßy l·ªánh (X)" onclick="game.cancelActiveModes(event)">‚úñ</div>
    </div>

    <div id="hero-status">
        <div style="width: 40px; height: 40px; background: var(--hero-color); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; border: 2px solid white;">üëë</div>
        <div>
            <div style="font-size: 12px; font-weight: bold; display: flex; justify-content: space-between;">
                ANH H√ôNG <span class="hero-lvl-badge" id="hero-lvl-text">LV1</span>
            </div>
            <div style="height: 6px; width: 100px; background: #444; border-radius: 3px; overflow: hidden; margin-top: 4px;">
                <div id="hero-hp-bar" style="height: 100%; width: 100%; background: #9b59b6;"></div>
            </div>
            <div style="height: 3px; width: 100px; background: #222; border-radius: 2px; overflow: hidden; margin-top: 2px;">
                <div id="hero-xp-bar" style="height: 100%; width: 0%; background: #3498db;"></div>
            </div>
        </div>
    </div>
    
    <div id="build-menu">
        <div class="menu-btn btn-archer" onclick="game.buildTower('ARCHER')">üèπ<br>70</div>
        <div class="menu-btn btn-mage" onclick="game.buildTower('MAGE')">‚ú®<br>100</div>
        <div class="menu-btn btn-barracks" onclick="game.buildTower('BARRACKS')">üõ°Ô∏è<br>80</div>
        <div class="menu-btn btn-artillery" onclick="game.buildTower('ARTILLERY')">üí£<br>125</div>
    </div>
    
    <div id="upgrade-menu">
        <div id="upg-btn" class="menu-btn btn-upgrade" onclick="game.upgradeTower()">‚ö°<br><span id="upg-cost">150</span></div>
        <div id="upg-spec-1-btn" class="menu-btn" style="display:none;" onclick="game.upgradeTower('spec1')">1Ô∏è‚É£<br>150</div>
        <div id="upg-spec-2-btn" class="menu-btn" style="display:none;" onclick="game.upgradeTower('spec2')">2Ô∏è‚É£<br>150</div>
        <div class="menu-btn btn-sell" onclick="game.sellTower()">üí∞<br><span id="sell-val">B√ÅN</span></div>
        <div id="rally-btn" class="menu-btn btn-rally" style="display:none;" onclick="game.startRally(event)">üö©<br>RALLY</div>
    </div>
    
    <div id="msg-overlay">
        <h1 id="msg-title">CHI·∫æN TH·∫ÆNG!</h1>
        <button class="control-btn" style="margin-top: 20px; padding: 10px 30px; background: var(--primary); border: none; color:black;" onclick="game.restart()">CH∆†I L·∫†I</button>
    </div>
</div>

<script>
/**
 * KINGDOM JS TD - ENGINE (The Strategic Reinforcements Update)
 */
const Sound = (() => {
    let audioCtx = null;
    const init = () => { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); };
    const playTone = (freq, type, duration, volume, slide = 0) => {
        init(); if (!audioCtx) return;
        try {
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            if (slide !== 0) osc.frequency.exponentialRampToValueAtTime(slide, audioCtx.currentTime + duration);
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        } catch(e) {}
    };
    return {
        build: () => playTone(150, 'square', 0.1, 0.2, 300),
        upgrade: () => playTone(400, 'triangle', 0.2, 0.2, 800),
        sword: () => playTone(1000, 'sine', 0.05, 0.06, 2000),
        horn: () => { playTone(330, 'sawtooth', 0.3, 0.15); setTimeout(() => playTone(440, 'sawtooth', 0.5, 0.15), 150); },
        whistle: () => playTone(1200, 'sine', 0.8, 0.08, 400),
        boom: () => playTone(60, 'square', 0.4, 0.25, 10),
        fire: () => playTone(200, 'sawtooth', 0.1, 0.08),
        heroLvl: () => playTone(523, 'sine', 0.4, 0.2, 1046),
        coin: () => playTone(900, 'sine', 0.1, 0.1),
        slam: () => playTone(80, 'square', 0.6, 0.3, 1),
        heroSelect: () => playTone(600, 'sine', 0.2, 0.1, 800),
        heroMove: () => playTone(400, 'sine', 0.1, 0.1, 200)
    };
})();

const CONFIG = { 
    WIDTH: 960, HEIGHT: 600, INITIAL_GOLD: 250, INITIAL_LIVES: 20,
    SKILLS: {
        RAIN: { cd: 45, damage: 400, count: 6 },
        REINFORCE: { cd: 15, duration: 15 },
        HERO_SLAM: { cd: 20, damage: 550, radius: 140, stunTime: 100 }
    }
};

const TOWER_DEFS = {
    ARCHER: { range: 160, fireRate: 45, cost: 70, type: 'archer', damage: 30, projectile: 'arrow', critRate: 0.15 },
    MAGE: { range: 140, fireRate: 75, cost: 100, type: 'mage', damage: 90, projectile: 'bolt' },
    BARRACKS: { range: 88, fireRate: 0, cost: 80, type: 'barracks', soldiers: 3, respawnTime: 700 }, 
    ARTILLERY: { range: 180, fireRate: 160, cost: 125, type: 'artillery', damage: 120, projectile: 'bomb' }
};

const ENEMY_DEFS = {
    GOBLIN: { hp: 300, speed: 1.6, gold: 8, color: '#2ecc71', size: 12, damage: 20, xp: 10 },
    ORC: { hp: 800, speed: 0.9, gold: 15, color: '#2f3640', size: 17, armor: 35, damage: 35, xp: 25, spawns: 2, demonic: true }, 
    ARMORED: { hp: 850, speed: 0.8, gold: 20, color: '#95a5a6', size: 16, armor: 80, damage: 45, xp: 30 },
    SHAMAN: { hp: 2000, speed: 1.2, gold: 40, color: '#483d8b', size: 16, mr: 75, damage: 50, xp: 50, demonic: true }, 
    RUNNER: { hp: 250, speed: 4.0, gold: 12, color: '#f1c40f', size: 10, damage: 35, xp: 15 },
    FLYING: { hp: 600, speed: 2.2, gold: 20, color: '#3498db', size: 14, flying: true, damage: 0, xp: 40 },
    TANK: { hp: 3000, speed: 0.6, gold: 150, color: '#1a1a1a', size: 30, armor: 60, mr: 60, damage: 100, xp: 200, spawns: 3 },
    BOSS: { hp: 9000, speed: 0.5, gold: 2000, color: '#c0392b', size: 55, armor: 80, mr: 80, isBoss: true, damage: 300, xp: 1000 }
};

const MAP_PATH = [{x: -50, y: 300}, {x: 200, y: 300}, {x: 200, y: 150}, {x: 500, y: 150}, {x: 500, y: 450}, {x: 800, y: 450}, {x: 800, y: 300}, {x: 1000, y: 300}];
const BUILD_PADS = [
    {x: 60, y: 360}, {x: 120, y: 240}, {x: 260, y: 360}, {x: 280, y: 240}, 
    {x: 350, y: 100}, {x: 420, y: 210}, {x: 580, y: 210}, {x: 420, y: 390}, 
    {x: 580, y: 390}, {x: 720, y: 390}, {x: 850, y: 240}, {x: 860, y: 360}, {x: 140, y: 190},
    {x: 650, y: 520} 
];
const DUEL_OFFSETS = [{ dx: -35, dy: -10 }, { dx: 0, dy: 15 }, { dx: 35, dy: -10 }];

class Splat {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color; this.life = 300; this.rotation = Math.random() * Math.PI * 2;
        this.size = 15 + Math.random() * 10;
        this.points = []; for(let i=0; i<6; i++) this.points.push({r: Math.random() * 10 + 5, a: (i/6)*Math.PI*2});
    }
    update() { this.life--; }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
        ctx.globalAlpha = Math.min(1, this.life / 100); ctx.fillStyle = this.color; ctx.beginPath();
        this.points.forEach((p, i) => { const px = Math.cos(p.a) * p.r * (this.size/10); const py = Math.sin(p.a) * p.r * (this.size/10); if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); });
        ctx.closePath(); ctx.fill(); ctx.restore();
    }
}

class FloatingText {
    constructor(x, y, text, color, size = 16, isCrit = false) {
        this.x = x; this.y = y; this.text = text; this.color = color;
        this.life = 60; this.size = size; this.isCrit = isCrit;
        this.vy = -1.5; this.vx = (Math.random() - 0.5) * 1.2;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw(ctx) {
        ctx.save(); ctx.globalAlpha = this.life / 60; ctx.fillStyle = this.color; ctx.font = `bold ${this.isCrit ? this.size*1.6 : this.size}px Segoe UI`;
        ctx.textAlign = "center"; ctx.strokeStyle = "black"; ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.x, this.y); ctx.fillText(this.text, this.x, this.y); ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, vx, vy, life) {
        this.x = x; this.y = y; this.color = color; this.vx = vx; this.vy = vy; this.life = life; this.maxLife = life;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw(ctx) { ctx.save(); ctx.globalAlpha = this.life/this.maxLife; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 2, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
}

class Hero {
    constructor() {
        this.reset();
        this.barksIdle = [
            "V∆∞∆°ng qu·ªëc tr∆∞·ªùng t·ªìn!", "Ta l√† huy·ªÅn tho·∫°i!", "V∆∞∆°ng qu·ªëc n√†y... tr·∫´m g√°nh h·∫øt!",
            "Ai d√°m th√°ch th·ª©c tr·∫´m?", "C·∫≠n v·ªá ƒë√¢u? C√≥ qu√°i k√¨a!", "Ta l√† b·ª©c t∆∞·ªùng th√†nh!", "Nh√¨n thanh ki·∫øm c·ªßa ta n√†y!"
        ];
        this.barksSelect = [
            "Tu√¢n l·ªánh!", "V√¨ vinh quang!", "M·ª•c ti√™u l√† ƒë√¢u?", "Ta ƒëang t·ªõi!", 
            "Ra l·ªánh ƒëi!", "V√¨ v∆∞∆°ng qu·ªëc!", "Ta ƒë√£ s·∫µn s√†ng.", "Ta s·∫Ω kh√¥ng l√†m ng√†i th·∫•t v·ªçng!"
        ];
        this.weaponShake = 0;
    }
    reset() {
        this.x = 100; this.y = 350; this.targetX = 100; this.targetY = 350;
        this.hp = 1800; this.maxHp = 1800; this.damage = 150; this.attackRate = 35; this.attackTimer = 0;
        this.lvl = 1; this.xp = 0; this.maxXp = 100;
        this.speed = 3.5; this.target = null; this.selected = false;
        this.barkText = ""; this.barkLife = 0; this.facing = 1; this.bob = 0;
        this.isDead = false; this.respawnTimer = 0;
        this.weaponShake = 0;
    }
    takeDamage(dmg) { 
        if (this.isDead) return;
        this.hp -= dmg; 
        // game.floatingTexts.push(new FloatingText(this.x, this.y, Math.floor(dmg), "#ff7675", 15));
        if (this.hp <= 0) { 
            this.hp = 0; this.isDead = true; this.respawnTimer = 600; 
            this.bark("TA S·∫º TR·ªû L·∫†I..."); 
            if (this.target) { const idx = this.target.blockers.indexOf(this); if (idx > -1) this.target.blockers.splice(idx, 1); this.target = null; }
        } 
    }
    gainXP(amount) {
        if (this.lvl >= 5 || this.isDead) return; this.xp += amount;
        if (this.xp >= this.maxXp) {
            this.lvl++; this.xp = 0; this.maxXp *= 2.5;
            this.maxHp += 500; this.hp = this.maxHp; this.damage += 50;
            Sound.heroLvl();
            // game.floatingTexts.push(new FloatingText(this.x, this.y - 40, "LEVEL UP!", "#f1c40f", 24, true)); game.shake(10);
        }
    }
    update() {
        if (this.isDead) { 
            this.respawnTimer--; 
            if (this.respawnTimer <= 0) { 
                this.isDead = false; this.hp = this.maxHp; this.x = this.targetX; this.y = this.targetY; 
                this.bark("TA ƒê√É TR·ªû L·∫†I!"); 
            } return; 
        }
        this.bob += 0.1; if (this.barkLife > 0) this.barkLife--;
        if (this.weaponShake > 0) this.weaponShake *= 0.8;

        const dxMove = this.targetX - this.x, dyMove = this.targetY - this.y;
        const distToDest = Math.sqrt(dxMove*dxMove + dyMove*dyMove);
        if (distToDest > 5) {
            if (this.target) { const idx = this.target.blockers.indexOf(this); if (idx > -1) this.target.blockers.splice(idx, 1); this.target = null; }
            this.facing = (dxMove > 0) ? 1 : -1; this.x += (dxMove/distToDest) * this.speed * game.timeScale; this.y += (dyMove/distToDest) * this.speed * game.timeScale; return;
        }
        const currentTarget = this.target;
        if (currentTarget) {
            if (currentTarget.dead) { const idx = currentTarget.blockers.indexOf(this); if (idx > -1) currentTarget.blockers.splice(idx, 1); this.target = null; } 
            else {
                this.attackTimer++; this.facing = (currentTarget.x > this.x) ? 1 : -1;
                if (this.attackTimer >= this.attackRate / game.timeScale) {
                    const isCrit = Math.random() < 0.25;
                    currentTarget.takeDamage(isCrit ? this.damage*2.5 : this.damage, 'phys', isCrit);
                    if (currentTarget.dead) this.gainXP(currentTarget.xp);
                    Sound.sword(); this.weaponShake = 15; this.attackTimer = 0;
                }
                return;
            }
        }
        if (this.hp < this.maxHp) this.hp += (0.4 * (2 + this.lvl)) * game.timeScale;
        let enemy = game.enemies.find(e => !e.flying && !e.dead && e.blockers.length === 0 && Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2) < 55);
        if (!enemy) enemy = game.enemies.find(e => !e.flying && !e.dead && e.blockers.length < 3 && Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2) < 55);
        if (enemy) { this.target = enemy; enemy.blockers.push(this); } 
        else if (this.barkLife <= 0 && Math.random() < 0.001) { this.bark(this.barksIdle[Math.floor(Math.random()*this.barksIdle.length)]); }
    }
    bark(txt) { this.barkText = txt; this.barkLife = 100; }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y + (this.isDead ? 0 : Math.sin(this.bob)*2));
        if (this.isDead) { ctx.rotate(Math.PI / 2); ctx.globalAlpha = Math.max(0, this.respawnTimer / 600); ctx.save(); ctx.rotate(-Math.PI / 2); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2 * (1 - this.respawnTimer/600)); ctx.stroke(); ctx.restore(); } 
        else { const auraAlpha = 0.3 + (this.lvl * 0.1); ctx.fillStyle = `rgba(155, 89, 182, ${auraAlpha})`; ctx.beginPath(); ctx.ellipse(0, 5, 20 + this.lvl*2, 12 + this.lvl, 0, 0, Math.PI*2); ctx.fill(); if (this.selected) { ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]); } }
        
        ctx.scale(this.facing, 1);
        ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.moveTo(-5, -10); ctx.lineTo(-22, 5); ctx.lineTo(-18, 18); ctx.fill(); 
        ctx.fillStyle = this.lvl >= 3 ? '#d4af37' : '#f1c40f'; ctx.beginPath(); ctx.roundRect(-10, -15, 20, 25, 5); ctx.fill();
        ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.arc(0, -20, 9, 0, Math.PI*2); ctx.fill(); 
        
        ctx.save();
        if (this.weaponShake > 0) ctx.rotate(Math.sin(this.weaponShake)*0.4);
        ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(8, 5); ctx.lineTo(25, -15); ctx.stroke(); 
        ctx.restore();
        
        ctx.restore();
        if (!this.isDead) { ctx.fillStyle = 'black'; ctx.fillRect(this.x-25, this.y-48, 50, 8); ctx.fillStyle = '#9b59b6'; ctx.fillRect(this.x-25, this.y-48, 50 * (this.hp/this.maxHp), 8); }
        if (this.barkLife > 0) {
            ctx.save(); ctx.font = "bold 14px Segoe UI"; const tw = ctx.measureText(this.barkText).width; ctx.fillStyle = "white"; ctx.beginPath(); ctx.roundRect(this.x-tw/2-10, this.y-80, tw+20, 26, 5); ctx.fill(); ctx.strokeStyle="black"; ctx.stroke();
            ctx.fillStyle="black"; ctx.textAlign="center"; ctx.fillText(this.barkText, this.x, this.y-62); ctx.restore();
        }
    }
}

class Soldier {
    constructor(parent, index, isTemp = false) {
        this.parent = parent; this.index = index; this.isTemp = isTemp; 
        this.reset();
        this.facing = 1; this.bob = Math.random() * Math.PI;
        this.barkText = ""; this.barkLife = 0;
        this.idleBarkTimer = Math.random() * 600;
        this.throwTimer = 0; this.weaponShake = 0;
        this.barksIdle = ["U·ªëng mi·∫øng n∆∞·ªõc kh√¥ng?", "V·ª£ ta n·∫•u ngon l·∫Øm!", "Ki·∫øm s·∫Øc kh√¥ng?", "Tr·ª±c ca ƒë√™m ch√°n th·∫≠t"];
        this.barksAttack = ["T·∫§N C√îNG!", "CH·∫∂N CH√öNG L·∫†I!", "V√å ƒê·ª®C VUA!"];
        this.barksHoly = ["√Ånh s√°ng d·∫´n ƒë∆∞·ªùng!", "V√¨ c√¥ng l√Ω!", "Khi√™n th√°nh b·∫£o v·ªá ta!"];
        this.barksBarb = ["R√¨u r·ªâ s√©t r·ªìi!", "Cho ta m·ªôt ng·ª•m bia!", "BIA ƒê√ÇU R·ªíI?"];
    }
    reset() {
        if (this.target) { const idx = this.target.blockers.indexOf(this); if (idx > -1) this.target.blockers.splice(idx, 1); this.target = null; }
        const lv = (this.parent.level || 1); const sub = this.parent.subType;
        if (this.isTemp) { this.hp = 200; this.maxHp = 200; this.damage = 20; this.armor = 0; }
        else if (sub === 'holy') { this.hp = 3000; this.maxHp = 3000; this.damage = 120; this.armor = 70; }
        else if (sub === 'barb') { this.hp = 2200; this.maxHp = 2200; this.damage = 250; this.armor = 10; }
        else { this.hp = 650 + (lv-1)*600; this.maxHp = this.hp; this.damage = 60 + (lv-1)*50; this.armor = (lv-1)*20; }
        this.attackRate = 45; this.attackTimer = 0; this.dead = false; this.respawnTimer = 0;

        this.x = (this.parent.rallyX || this.parent.x) + DUEL_OFFSETS[this.index].dx;
        this.y = (this.parent.rallyY || this.parent.y) + DUEL_OFFSETS[this.index].dy;
        this.weaponShake = 0; this.throwTimer = 0;
    }
    bark(txt) { this.barkText = txt; this.barkLife = 100; }
    update() {
        this.bob += 0.15; if (this.dead) return;
        if (this.barkLife > 0) this.barkLife--;
        if (this.weaponShake > 0) this.weaponShake *= 0.8;
        if (this.isTemp) { if (!this.lifeSpan) this.lifeSpan = CONFIG.SKILLS.REINFORCE.duration * 60; this.lifeSpan--; if(this.lifeSpan <= 0) { this.dead = true; if(this.target) { const idx = this.target.blockers.indexOf(this); if (idx > -1) this.target.blockers.splice(idx, 1); this.target = null; } return; } }
        const trx = this.parent.rallyX || this.parent.x, tryy = this.parent.rallyY || this.parent.y;
        const destX = trx + DUEL_OFFSETS[this.index].dx, destY = tryy + DUEL_OFFSETS[this.index].dy;
        const dxMove = destX - this.x, dyMove = destY - this.y;
        const distToDest = Math.sqrt(dxMove*dxMove + dyMove*dyMove);
        if (distToDest > 5) {
            if (this.target) { const idx = this.target.blockers.indexOf(this); if (idx > -1) this.target.blockers.splice(idx, 1); this.target = null; }
            this.facing = (dxMove > 0) ? 1 : -1; this.x += (dxMove/distToDest) * 2.8 * game.timeScale; this.y += (dyMove/distToDest) * 2.8 * game.timeScale; return;
        }
        const currentTarget = this.target;
        if (currentTarget) {
            if (currentTarget.dead) { const idx = currentTarget.blockers.indexOf(this); if (idx > -1) currentTarget.blockers.splice(idx, 1); this.target = null; } 
            else { 
                this.attackTimer++; this.facing = (currentTarget.x > this.x) ? 1 : -1; 
                if (this.attackTimer >= this.attackRate / game.timeScale) { currentTarget.takeDamage(this.damage, 'phys'); Sound.sword(); this.weaponShake = 15; this.attackTimer = 0; } 
                return; 
            }
        }
        
        // NO REGEN (User preference maintained)

        let enemy = game.enemies.find(e => !e.flying && !e.dead && e.blockers.length === 0 && Math.sqrt((e.x-trx)**2 + (e.y-tryy)**2) < 55);
        if (!enemy) enemy = game.enemies.find(e => !e.flying && !e.dead && e.blockers.length < 3 && Math.sqrt((e.x-trx)**2 + (e.y-tryy)**2) < 55);

        if (enemy) { 
            if (!this.target) {
                const sub = this.parent.subType;
                const set = sub === 'holy' ? this.barksHoly : (sub === 'barb' ? this.barksBarb : this.barksAttack);
                this.bark(set[Math.floor(Math.random()*set.length)]);
            }
            this.target = enemy; enemy.blockers.push(this); 
        } else {
            if (this.parent.subType === 'barb') {
                this.throwTimer++;
                if (this.throwTimer >= 100 / game.timeScale) {
                    const t = game.enemies.find(e => !e.dead && Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2) < 180);
                    if (t) { 
                        game.projectiles.push({x:this.x, y:this.y-10, target:t, type:'heavy_hoe', dmg: 100, speed: 10, angle: 0});
                        this.throwTimer = 0; 
                        this.weaponShake = 20; 
                    }
                }
            }
            this.idleBarkTimer++; if (this.idleBarkTimer >= 600) { this.bark(this.barksIdle[Math.floor(Math.random()*this.barksIdle.length)]); this.idleBarkTimer = 0; }
        }
    }
    takeDamage(dmg) { 
        let f = dmg * (1 - (this.armor||0)/100); 
        this.hp -= f; 
        // game.floatingTexts.push(new FloatingText(this.x, this.y, Math.floor(f), "#ff7675", 13)); 
        if (this.hp <= 0) { 
            this.dead = true; 
            this.respawnTimer = 0; 
            if (this.target) { const idx = this.target.blockers.indexOf(this); if (idx > -1) this.target.blockers.splice(idx, 1); this.target = null; } 
        } 
    }
    draw(ctx) {
        if (this.dead) return; ctx.save(); ctx.translate(this.x, this.y + Math.sin(this.bob)*1.5); ctx.scale(this.facing, 1);
        const sub = this.parent.subType;
        if (sub === 'holy') {
            // 1. V·∫Ω √°o cho√†ng (Cape)
            ctx.fillStyle = '#2980b9'; // M√†u xanh ho√†ng gia
            ctx.beginPath();
            ctx.moveTo(-8, -5);
            ctx.lineTo(-12, 15);
            ctx.lineTo(8, 15);
            ctx.lineTo(5, -5);
            ctx.fill();

            // 2. Th√¢n gi√°p tr·ª• (Full Plate Armor)
            ctx.fillStyle = '#d4af37'; // Gi√°p v√†ng
            ctx.beginPath();
            ctx.roundRect(-10, -16, 20, 26, 4);
            ctx.fill();
            
            // Vi·ªÅn b·∫°c cho gi√°p
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Bi·ªÉu t∆∞·ª£ng Th√°nh gi√° tr√™n ng·ª±c
            ctx.fillStyle = 'white';
            ctx.fillRect(-1, -10, 2, 12);
            ctx.fillRect(-4, -7, 8, 2);

            // 3. M≈© gi√°p (Great Helm)
            ctx.fillStyle = '#bdc3c7'; // M√†u th√©p s√°ng
            ctx.beginPath();
            ctx.arc(0, -20, 9, 0, Math.PI * 2);
            ctx.fill();
            
            // Khe nh√¨n c·ªßa m≈© gi√°p
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(-5, -21, 10, 2);
            
            // M√†o m≈© (Plume)
            ctx.fillStyle = '#e74c3c'; // M√†o ƒë·ªè r·ª±c
            ctx.beginPath();
            ctx.moveTo(0, -28);
            ctx.quadraticCurveTo(-10, -35, -15, -25);
            ctx.lineTo(0, -25);
            ctx.fill();

            // 4. Khi√™n Th√°nh (Holy Shield) - V·∫Ω b√™n tay tr√°i
            ctx.save();
            ctx.translate(-12, 0);
            ctx.fillStyle = '#f1c40f'; // Vi·ªÅn v√†ng
            ctx.beginPath();
            ctx.moveTo(0, -8);
            ctx.lineTo(10, -8);
            ctx.lineTo(10, 5);
            ctx.lineTo(5, 12);
            ctx.lineTo(0, 5);
            ctx.closePath();
            ctx.fill();
            // Ru·ªôt khi√™n tr·∫Øng
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(2, -6);
            ctx.lineTo(8, -6);
            ctx.lineTo(8, 4);
            ctx.lineTo(5, 9);
            ctx.lineTo(2, 4);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

        }
        else if (sub === 'barb') {
            const bob = Math.sin(this.bob) * 1.5;
            
            // --- 1. TH√ÇN H√åNH V·∫†M V·ª† (BUFF N√îNG D√ÇN) ---
            // Qu·∫ßn y·∫øm b√≤ (Overalls)
            ctx.fillStyle = '#2c3e50'; 
            ctx.beginPath();
            ctx.roundRect(-10, -12, 20, 20, 2);
            ctx.fill();
            
            // Ng·ª±c tr·∫ßn c∆° b·∫Øp (M√†u da r√°m n·∫Øng)
            ctx.fillStyle = '#e0ac69'; 
            ctx.beginPath();
            ctx.roundRect(-10, -18, 20, 10, 5); 
            ctx.fill();
            
            // Hai quai d√¢y ƒëeo qu·∫ßn y·∫øm
            ctx.fillStyle = '#34495e';
            ctx.fillRect(-9, -18, 3, 10);
            ctx.fillRect(6, -18, 3, 10);

            // --- 2. ƒê·∫¶U V√Ä R√ÇU QUAI N√ìN ---
            ctx.fillStyle = '#e0ac69'; // M·∫∑t
            ctx.beginPath(); ctx.arc(0, -20, 6, 0, Math.PI * 2); ctx.fill();
            
            // R√¢u quai n√≥n r·∫≠m r·∫°p (ƒê·∫∑c tr∆∞ng l·ª±c ƒëi·ªÅn)
            ctx.fillStyle = '#5d4037';
            ctx.beginPath();
            ctx.arc(0, -18, 5, 0, Math.PI); // R√¢u d∆∞·ªõi c·∫±m
            ctx.fill();
            
            // KhƒÉn qu·∫•n ƒë·∫ßu (Bandana) ƒë·ªè
            ctx.fillStyle = '#c0392b';
            ctx.beginPath();
            ctx.arc(0, -22, 6, Math.PI, 0);
            ctx.fill();
            ctx.fillRect(-6, -23, 12, 2);

            // --- 3. C√ÅNH TAY L·ª∞C L∆Ø·ª†NG ---
            ctx.fillStyle = '#e0ac69';
            // Tay c·∫ßm v≈© kh√≠
            ctx.save();
            if (this.weaponShake > 0) ctx.rotate(Math.sin(this.weaponShake) * 0.4);
            ctx.beginPath();
            ctx.ellipse(10, -12, 4, 8, -Math.PI/4, 0, Math.PI*2); // B·∫Øp tay ph·∫£i
            ctx.fill();
            
            // --- V≈® KH√ç: R√åU CHI·∫æN G·ªà S√âT HO·∫∂C C√ÄO C·ªé ---
            ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(10, -10); ctx.lineTo(18, -25); ctx.stroke(); // C√°n
            
            // L∆∞·ª°i r√¨u to b·∫£n, th√¥ k·ªách
            ctx.fillStyle = '#7f8c8d';
            ctx.beginPath();
            ctx.moveTo(16, -25); ctx.lineTo(26, -30); ctx.lineTo(24, -15); ctx.lineTo(14, -22);
            ctx.closePath(); ctx.fill();
            // V·∫øt m√°u/g·ªâ s√©t tr√™n r√¨u
            ctx.fillStyle = '#8e44ad'; // M√†u t√≠m/ƒë·ªè th·∫´m
            ctx.fillRect(20, -25, 3, 5);
            ctx.restore();

            // Tay c·∫ßm khi√™n g·ªó th√¥ (T√πy ch·ªçn)
            ctx.beginPath();
            ctx.ellipse(-10, -12, 4, 8, Math.PI/4, 0, Math.PI*2); // B·∫Øp tay tr√°i
            ctx.fill();
        }
        else if (this.isTemp) { ctx.fillStyle = '#8d6e63'; ctx.beginPath(); ctx.roundRect(-7, -12, 14, 20, 3); ctx.fill(); ctx.fillStyle = '#ffe0bd'; ctx.beginPath(); ctx.arc(0, -15, 6, 0, Math.PI*2); ctx.fill(); } 
        else { const lv = (this.parent.level || 1); ctx.fillStyle = lv === 1 ? '#2980b9' : '#2c3e50'; ctx.beginPath(); ctx.roundRect(-8, -14, 16, 22, 4); ctx.fill(); ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.arc(0, -16, 7, 0, Math.PI*2); ctx.fill(); }
        // Th√™m v√†o ƒë·∫ßu h√†m draw(ctx) c·ªßa class Soldier, tr∆∞·ªõc khi save()
        if (this.parent.subType === 'holy' && !this.dead) {
            ctx.save();
            ctx.globalAlpha = 0.3 + Math.sin(game.ticks * 0.1) * 0.2;
            ctx.fillStyle = '#f1c40f';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#f1c40f';
            ctx.beginPath();
            ctx.ellipse(this.x, this.y + 15, 18, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        ctx.save(); if (this.weaponShake > 0) ctx.rotate(Math.sin(this.weaponShake)*0.4);
        if (sub === 'barb') { ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(8, 5); ctx.lineTo(15, -15); ctx.stroke(); ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.arc(15, -15, 6, -1, 1); ctx.fill(); } 
        else { ctx.strokeStyle = sub === 'holy' ? '#00d2ff' : '#bdc3c7'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(8, 5); ctx.lineTo(20, -10); ctx.stroke(); }
        ctx.restore(); ctx.restore(); 
        ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(this.x-12, this.y+15, 24, 4); ctx.fillStyle = '#2ecc71'; ctx.fillRect(this.x-12, this.y+15, 24*(this.hp/this.maxHp), 4);
        if (this.barkLife > 0) { ctx.save(); ctx.font = "bold 11px Segoe UI"; const tw = ctx.measureText(this.barkText).width; ctx.fillStyle = "white"; ctx.beginPath(); ctx.roundRect(this.x-tw/2-5, this.y-50, tw+10, 18, 4); ctx.fill(); ctx.strokeStyle="black"; ctx.stroke(); ctx.fillStyle="black"; ctx.textAlign="center"; ctx.fillText(this.barkText, this.x, this.y-37); ctx.restore(); }
    }
}

class Enemy {
    constructor(typeKey, x, y, wp) {
        Object.assign(this, ENEMY_DEFS[typeKey]); this.typeKey = typeKey; this.maxHp = this.hp;
        this.x = x !== undefined ? x : MAP_PATH[0].x; this.y = y !== undefined ? y : MAP_PATH[0].y;
        this.wpIdx = wp !== undefined ? wp : 0; this.dead = false; this.reached = false; 
        this.blockers = []; this.attackTimer = 0; this.stunned = 0; this.facing = 1; this.bob = Math.random() * Math.PI;
        this.burnTimer = 0; this.slowTimer = 0; this.bossAbilityTimer = 0;
    }

    executeDelayedExplosion() {
        if (this.dead) return;
        const splashRadius = 80;
        const splashDmg = 150; // S√°t th∆∞∆°ng v·ª• n·ªï

        // Hi·ªáu ·ª©ng h√¨nh ·∫£nh v·ª• n·ªï
        game.effects.push({
            x: this.x, y: this.y, 
            life: 20, maxLife: 20, 
            color: 'rgba(231, 76, 60, 0.8)', 
            r: splashRadius 
        });

        // Th√™m h·∫°t l·ª≠a ph√°o hoa
        for(let i=0; i<10; i++) {
            const ang = Math.random() * Math.PI * 2;
            game.particles.push(new Particle(this.x, this.y, '#e67e22', Math.cos(ang)*5, Math.sin(ang)*5, 20));
        }

        // G√¢y s√°t th∆∞∆°ng lan xung quanh
        game.enemies.forEach(e => {
            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
            if (dist < splashRadius && !e.dead) {
                e.takeDamage(splashDmg, 'magic');
            }
        });

        Sound.boom();
        // G√¢y s√°t th∆∞∆°ng ch√≠nh cho b·∫£n th√¢n qu√°i v·∫≠t mang bom (c√≥ th·ªÉ g√¢y ch·∫øt ngay)
        this.takeDamage(splashDmg, 'magic', true);
    }
    update() {
        this.bob += 0.2; if (this.dead) return;
        // --- TH√äM LOGIC N·ªî CH·∫¨M CHO CUNG L·ª¨A LV3 ---
        if (this.bombTimer > 0) {
            this.bombTimer--;
            if (this.bombTimer <= 0) {
                this.executeDelayedExplosion(); // G·ªçi h√†m n·ªï
            }
        }
        if (this.isBoss) { this.bossAbilityTimer++; if (this.bossAbilityTimer >= 300) { this.bossAbilityTimer = 0; Sound.slam(); game.shake(20); game.effects.push({x:this.x, y:this.y, life:40, maxLife:40, color:'rgba(192, 57, 43, 0.4)', r:180}); const radius = 180; if (!game.hero.isDead && Math.sqrt((game.hero.x-this.x)**2 + (game.hero.y-this.y)**2) < radius) game.hero.takeDamage(100); game.towers.forEach(t => t.soldiers.forEach(s => { if (!s.dead && Math.sqrt((s.x-this.x)**2 + (s.y-this.y)**2) < radius) s.takeDamage(100); })); game.militia.forEach(s => { if (!s.dead && Math.sqrt((s.x-this.x)**2 + (s.y-this.y)**2) < radius) s.takeDamage(100); }); } }
        let currentSpeed = this.speed; if (this.slowTimer > 0) { this.slowTimer--; currentSpeed *= 0.5; }
        if (this.burnTimer > 0) { 
            this.burnTimer--; 
            if (this.burnTimer % 30 === 0) this.takeDamage(20, 'magic'); 
            if (Math.random() < 0.4) game.particles.push(new Particle(this.x + (Math.random()-0.5)*15, this.y - 10, '#e67e22', (Math.random()-0.5)*2, -3, 20));
        }
        if (this.stunned > 0) { this.stunned--; return; }
        if (this.blockers.length > 0) {
            const b = this.blockers[0]; 
            if (b.dead || (b instanceof Hero && b.isDead) || b.target !== this) { 
                const idx = this.blockers.indexOf(b); 
                if (idx > -1) this.blockers.splice(idx, 1); 
                return; 
            }
            this.facing = (b.x > this.x) ? 1 : -1; 
            const tx = b.x + (this.x < b.x ? -7 : 7); 
            this.x += (tx - this.x) * 0.2; 
            this.y += (b.y - this.y) * 0.2; 
            
            // N·∫øu qu√°i v·∫≠t kh√¥ng b·ªã cho√°ng (ƒë√£ check ·ªü tr√™n), n√≥ m·ªõi ƒë∆∞·ª£c tƒÉng timer t·∫•n c√¥ng
            this.attackTimer++; 
            if (this.attackTimer >= 60 / game.timeScale) { 
                b.takeDamage(this.damage || 20); 
                this.attackTimer = 0; 
            } 
            return;
        }
        let target = MAP_PATH[this.wpIdx + 1]; if (!target) { this.reached = true; this.dead = true; game.shake(12); return; }
        const dx = target.x - this.x, dy = target.y - this.y, d = Math.sqrt(dx*dx + dy*dy); if (d < currentSpeed * game.timeScale) this.wpIdx++; else { this.facing = (dx > 0) ? 1 : -1; this.x += (dx/d)*currentSpeed*game.timeScale; this.y += (dy/d)*currentSpeed*game.timeScale; }
    }
    takeDamage(dmg, type, isCrit = false) {
        let f = dmg; if (type === 'phys') f *= (1 - (this.armor||0)/100); if (type === 'magic') f *= (1 - (this.mr||0)/100);
        // this.hp -= f; game.floatingTexts.push(new FloatingText(this.x, this.y, Math.floor(f), isCrit ? "#ff9f43" : "white", 16, isCrit));
        // if (isCrit) game.floatingTexts.push(new FloatingText(this.x, this.y - 22, "CRIT!", "#ee5253", 18, true));
        this.hp -= f; 
        // Ch·ªâ t·∫°o FloatingText n·∫øu l√† ƒë√≤n ƒë√°nh ch√≠ m·∫°ng
        if (isCrit) {
            game.floatingTexts.push(new FloatingText(this.x, this.y, Math.floor(f), "#ff9f43", 16, true));
            game.floatingTexts.push(new FloatingText(this.x, this.y - 22, "CRIT!", "#ee5253", 18, true));
        }
        if (this.hp <= 0 && !this.dead) { this.dead = true; game.gold += this.gold; Sound.coin(); game.splats.push(new Splat(this.x, this.y, this.armor > 50 ? "rgba(70,70,70,0.5)" : "rgba(180,0,0,0.4)")); this.blockers.forEach(b => { if(b.target === this) b.target = null; }); this.blockers = []; }
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y + Math.sin(this.bob)*2); ctx.scale(this.facing, 1);
        if (this.slowTimer > 0) { 
            ctx.shadowBlur = 10; ctx.shadowColor = '#3498db'; 
            ctx.fillStyle = 'rgba(52, 152, 219, 0.4)'; ctx.beginPath(); ctx.ellipse(0, 0, this.size+2, (this.size+2)*0.8, 0, 0, Math.PI*2); ctx.fill();
        }
        if (this.stunned > 0 && this.slowTimer > 0) { // Check n·∫øu ƒëang b·ªã cho√°ng b·ªüi bƒÉng
            ctx.save();
            ctx.fillStyle = 'rgba(129, 236, 236, 0.6)'; // M√†u bƒÉng xanh nh·∫°t
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            // V·∫Ω kh·ªëi bƒÉng bao quanh qu√°i
            ctx.beginPath();
            ctx.roundRect(-this.size-2, -this.size-2, this.size*2+4, this.size*2+4, 4);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        if (this.burnTimer > 0) {
            ctx.fillStyle = '#e67e22'; for(let i=0; i<3; i++) { const ox = (Math.random()-0.5)*15, oy = -Math.random()*15; ctx.beginPath(); ctx.arc(ox, oy, 4, 0, Math.PI*2); ctx.fill(); }
            ctx.shadowBlur = 15; ctx.shadowColor = '#e67e22';
        }
        if (this.bombTimer > 0) {
            // Nh·∫•p nh√°y ƒë·ªè nhanh d·∫ßn khi s·∫Øp n·ªï
            const flash = Math.sin(this.bombTimer * 0.5) > 0;
            if (flash) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'red';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.beginPath(); ctx.arc(0, 0, this.size + 5, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        const s = this.size;
        if (this.typeKey === 'TANK') {
            ctx.fillStyle = '#1a1a1a'; // Obsidian body
            ctx.beginPath(); ctx.roundRect(-s, -s*0.8, s*2, s*1.6, 8); ctx.fill();
            ctx.fillStyle = '#111'; ctx.beginPath(); ctx.moveTo(-s, 0); ctx.lineTo(-s-8, -10); ctx.lineTo(-s, -5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(s, 0); ctx.lineTo(s+8, -10); ctx.lineTo(s, -5); ctx.fill();
            ctx.strokeStyle = '#e84118'; ctx.lineWidth = 2; ctx.shadowBlur = 5; ctx.shadowColor = 'red';
            ctx.beginPath(); ctx.moveTo(-s*0.7, -s*0.3); ctx.lineTo(-s*0.2, s*0.4); ctx.moveTo(s*0.3, -s*0.5); ctx.lineTo(s*0.8, s*0.2); ctx.stroke();
            ctx.fillStyle = '#2f3640'; ctx.shadowBlur = 0;
            ctx.beginPath(); ctx.moveTo(-s, -s*0.5); ctx.lineTo(-s*1.3, -s*1.2); ctx.lineTo(-s*0.7, -s*0.5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(s, -s*0.5); ctx.lineTo(s*1.3, -s*1.2); ctx.lineTo(s*0.7, -s*0.5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-s*0.4, -s*0.8); ctx.lineTo(-s*0.6, -s*1.4); ctx.lineTo(-s*0.2, -s*0.8); ctx.fill();
            ctx.beginPath(); ctx.moveTo(s*0.4, -s*0.8); ctx.lineTo(s*0.6, -s*1.4); ctx.lineTo(s*0.2, -s*0.8); ctx.fill();
            ctx.fillStyle = '#fbc531'; ctx.shadowBlur = 10; ctx.shadowColor = 'orange';
            ctx.beginPath(); ctx.arc(-s*0.4, -s*0.2, 4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(s*0.4, -s*0.2, 4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(0, -s*0.4, 5, 0, Math.PI*2); ctx.fill();
        }
        else if (this.typeKey === 'SHAMAN') {
            ctx.fillStyle = '#483d8b'; ctx.beginPath(); ctx.moveTo(-s, s); ctx.lineTo(s, s); ctx.lineTo(0, -s*1.2); ctx.closePath(); ctx.fill();
            ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(0, -s*0.3, s*0.5, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(-2, -s*0.4, 2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(2, -s*0.4, 2, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#2f4f4f'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(s, s); ctx.lineTo(s*1.5, -s); ctx.stroke();
            ctx.fillStyle = '#ff00ff'; ctx.shadowBlur = 15; ctx.shadowColor = '#ff00ff'; ctx.beginPath(); ctx.arc(s*1.5, -s, 5, 0, Math.PI*2); ctx.fill();
        } 
        else if (this.typeKey === 'ORC') {
            ctx.fillStyle = '#2f3640'; ctx.beginPath(); ctx.ellipse(0, 0, s, s*0.9, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.moveTo(-s*0.5, -s*0.8); ctx.lineTo(-s*0.8, -s*1.5); ctx.lineTo(-s*0.2, -s*0.8); ctx.fill();
            ctx.beginPath(); ctx.moveTo(s*0.5, -s*0.8); ctx.lineTo(s*0.8, -s*1.5); ctx.lineTo(s*0.2, -s*0.8); ctx.fill();
            ctx.fillStyle = '#e84118'; ctx.shadowBlur = 10; ctx.shadowColor = 'red';
            ctx.beginPath(); ctx.arc(-s*0.3, -s*0.2, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(s*0.3, -s*0.2, 3, 0, Math.PI*2); ctx.fill();
        }
        else if (this.typeKey === 'GOBLIN') { ctx.fillStyle = this.color; ctx.beginPath(); ctx.ellipse(0, 0, s, s*0.8, 0, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(-s*0.5, -s*0.5); ctx.lineTo(-s, -s); ctx.lineTo(-s*0.2, -s*0.5); ctx.fill(); ctx.beginPath(); ctx.moveTo(s*0.5, -s*0.5); ctx.lineTo(s, -s); ctx.lineTo(s*0.2, -s*0.5); ctx.fill(); } 
        else if (this.typeKey === 'RUNNER') { ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(-s, 0); ctx.lineTo(s, 0); ctx.lineTo(0, -s*1.5); ctx.closePath(); ctx.fill(); }
        else if (this.typeKey === 'ARMORED') { ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.roundRect(-s, -s, s*2, s*2, 4); ctx.fill(); ctx.fillStyle = 'red'; ctx.fillRect(-s*0.6, -s*0.3, s*1.2, 3); }
        else if (this.typeKey === 'FLYING') { ctx.fillStyle = this.color; ctx.beginPath(); ctx.ellipse(0, -5, s, s*0.7, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.moveTo(s*0.8, -5); ctx.lineTo(s*1.4, -2); ctx.lineTo(s*0.8, 1); ctx.closePath(); ctx.fill(); const flap = Math.sin(game.ticks * 0.2) * s; ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(-s, -5-flap); ctx.lineTo(-s*0.5, -5); ctx.fill(); ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(s, -5-flap); ctx.lineTo(s*0.5, -5); ctx.fill(); }
        else if (this.isBoss) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.ellipse(0, 0, s, s*0.9, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'gold'; ctx.beginPath(); ctx.moveTo(-s*0.7, -s*0.8); ctx.lineTo(-s*0.4, -s*1.4); ctx.lineTo(0, -s*0.9); ctx.lineTo(s*0.4, -s*1.4); ctx.lineTo(s*0.7, -s*0.8); ctx.closePath(); ctx.fill(); ctx.fillStyle = 'red'; ctx.shadowBlur = 15; ctx.shadowColor = 'red'; ctx.beginPath(); ctx.arc(-s*0.3, -s*0.2, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(s*0.3, -s*0.2, 4, 0, Math.PI*2); ctx.fill(); }
        else { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, s, 0, Math.PI*2); ctx.fill(); }
        ctx.restore();
        ctx.fillStyle = 'black'; ctx.fillRect(this.x-15, this.y-this.size-12, 30, 5); ctx.fillStyle = '#f1c40f'; ctx.fillRect(this.x-15, this.y-this.size-12, 30*(this.hp/this.maxHp), 5);
    }
}

class Tower {
    constructor(pad, typeKey) {
        this.pad = pad; Object.assign(this, TOWER_DEFS[typeKey]);
        this.x = pad.x; this.y = pad.y; this.level = 1; this.timer = 0;
        this.rallyX = pad.x; this.rallyY = pad.y + 30;
        this.soldiers = []; this.subType = null;
        this.angle = 0; this.recoil = 0; this.archerFacing = 1;
        this.barkText = ""; this.barkLife = 0; this.idleBarkTimer = Math.random() * 600;
        if (this.type === 'barracks') for(let i=0; i<3; i++) this.soldiers.push(new Soldier(this, i));
    }
    update() {
        if (this.barkLife > 0) this.barkLife--;
        if (this.type === 'barracks') { this.soldiers.forEach(s => { if(s.dead) { s.respawnTimer++; if(s.respawnTimer >= 700 / game.timeScale) s.reset(); } else s.update(); }); return; }
        
        if (this.subType === 'fire' && Math.random() < 0.2) {
            game.particles.push(new Particle(this.x + (Math.random()-0.5)*20, this.y - 40, '#e67e22', (Math.random()-0.5)*1, -2, 30));
        }

        this.timer++; if (this.recoil > 0) this.recoil *= 0.8;
        const t = game.enemies.find(e => Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2) <= this.range && (this.type !== 'artillery' || !e.flying));
        if (t) {
            this.angle = Math.atan2(t.y - this.y, t.x - this.x); this.archerFacing = (t.x > this.x) ? 1 : -1;
            if (this.timer >= this.fireRate / game.timeScale) { 
                let isCrit = false, dmg = this.damage; 
                if (this.type === 'archer' && Math.random() < 0.15) { isCrit = true; dmg *= 2.5; }
                const projType = this.subType ? `arrow_${this.subType}` : this.projectile;

                // --- T√çNH TO√ÅN T·ªåA ƒê·ªò B·∫ÆN CH√çNH X√ÅC ---
                let startX = this.x;
                let startY = this.y;

                if (this.type === 'archer') {
                    // Archer ƒë·ª©ng tr√™n ban c√¥ng, t·ªça ƒë·ªô y th∆∞·ªùng l√† y_tower - chi·ªÅu cao th√°p
                    // D·ª±a tr√™n code v·∫Ω: ban c√¥ng ·ªü kho·∫£ng -24 - lv*10
                    startY = this.y - 24 - this.level * 10;
                    // N·∫øu c√≥ 2 cung th·ªß (lv3), l·∫•y v·ªã tr√≠ cung th·ªß g·∫ßn m·ª•c ti√™u h∆°n ho·∫∑c m·∫∑c ƒë·ªãnh
                    if (this.level === 3) startX = this.x + (t.x > this.x ? 12 : -12);
                } 
                else if (this.type === 'mage') {
                    // Mage b·∫Øn ra t·ª´ qu·∫£ c·∫ßu/tinh th·ªÉ ƒë·ªânh th√°p
                    // D·ª±a tr√™n code v·∫Ω: crystalCenterY = -75 - lv * 10 + floatY
                    const floatY = Math.sin(game.ticks * 0.05) * 6;
                    startY = this.y - 75 - this.level * 10 + floatY;
                }
                else if (this.type === 'artillery') {
                    // Artillery b·∫Øn ra t·ª´ ƒë·∫ßu n√≤ng ph√°o
                    const barrelLen = 35 + this.level * 5;
                    startX = this.x + Math.cos(this.angle) * barrelLen;
                    startY = this.y + Math.sin(this.angle) * barrelLen;
                }

                // Push projectile v·ªõi t·ªça ƒë·ªô kh·ªüi t·∫°o m·ªõi (startX, startY)
                game.projectiles.push({
                    x: startX, 
                    y: startY, 
                    target: t, 
                    type: projType, 
                    dmg: dmg, 
                    speed: this.type === 'artillery' ? 6 : 15, 
                    isCrit: isCrit, 
                    subType: this.subType,
                    towerLevel: this.level // TH√äM D√íNG N√ÄY
                }); 

                Sound.fire(); 
                this.timer = 0; 
                this.recoil = 10;
            }
        } else if (this.type === 'archer') {
            this.idleBarkTimer++; 
            if (this.idleBarkTimer >= 600) {
                const linesIce = ["L·∫°nh teo bug lu√¥n!", "Kem que ƒë√¢y!", "Th√™m ƒë√° kh√¥ng?"];
                const linesFire = ["G√† n∆∞·ªõng th√¥i!", "S·∫Øp c√≥ th·ªãt n∆∞·ªõng!", "N√≥ng b·ªèng m·∫Øt!"];
                const linesStd = ["Gi√≥ T√¢y B·∫Øc...", "Wifi y·∫øu qu√°!", "√îng h√†ng x√≥m k√¨a!", "M·ªèi m·∫Øt qu√°!"];
                const currentLines = this.subType === 'ice' ? linesIce : (this.subType === 'fire' ? linesFire : linesStd);
                this.barkText = currentLines[Math.floor(Math.random()*currentLines.length)]; this.barkLife = 120; this.idleBarkTimer = 0;
            }
        }
    }
    upgrade(branch) {
        if (this.level < 3) {
            if (this.type === 'archer' && this.level === 1) this.subType = branch === 'spec1' ? 'ice' : 'fire';
            if (this.type === 'barracks' && this.level === 2) this.subType = branch === 'spec1' ? 'holy' : 'barb';
            this.level++; this.damage *= 2.0; this.range += 20;
            // --- CH·ªàNH T·ªêC ƒê·ªò B·∫ÆN CHO CUNG BƒÇNG LEVEL 3 ---
            if (this.level === 3 && (this.subType === 'ice' || this.subType === 'fire')) {
                // tƒÉng fireRate l√™n 90, b·∫Øn ch·∫≠m l·∫°i ƒë·ªÉ c√¢n b·∫±ng
                this.fireRate = 90; 
            } else if (this.level === 3) {
                // C√°c th√°p level 3 kh√°c gi·∫£m nh·∫π fireRate (t√πy ch·ªçn)
                this.fireRate = 70;
            }
            else if(this.level === 2){
                this.fireRate = 55;
            }
            if(this.type === 'barracks') this.soldiers.forEach(s => s.reset());
        }
    }
    draw(ctx) {
        // if (this.type === 'barracks') { this.soldiers.forEach(s => s.draw(ctx)); ctx.strokeStyle = '#3498db'; ctx.setLineDash([3,3]); ctx.beginPath(); ctx.arc(this.rallyX, this.rallyY, 15, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]); }
        ctx.save(); ctx.translate(this.x, this.y); const lv = this.level;
        if (this.type === 'archer') {
            const accent = this.subType === 'ice' ? '#3498db' : (this.subType === 'fire' ? '#e67e22' : '#7f8c8d');
            const lv = this.level;

            // --- 1. HI·ªÜU ·ª®NG H√ÄO QUANG & TRANG TR√ç D∆Ø·ªöI ƒê·∫§T ---
            if (this.subType) {
                ctx.save();
                // H√†o quang n·ªÅn nh·∫•p nh√°y
                ctx.globalAlpha = 0.15 + Math.sin(game.ticks * 0.05) * 0.05; 
                ctx.fillStyle = accent;
                ctx.shadowBlur = 25;
                ctx.shadowColor = accent;
                ctx.beginPath();
                ctx.ellipse(0, 5, 42, 16, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // --- TRANG TR√ç ƒê·∫∂C TR∆ØNG H·ªÜ (C·∫¨P NH·∫¨T 2 B√äN) ---
                ctx.save();
                if (this.subType === 'fire') {
                    // V·∫Ω 2 ng·ªçn ƒëu·ªëc
                    const drawTorch = (tx) => {
                        ctx.fillStyle = '#5d4037';
                        ctx.fillRect(tx - 2, -5, 4, 15);
                        const fSize = 4 + Math.sin(game.ticks * 0.2) * 2;
                        ctx.fillStyle = '#e67e22';
                        ctx.shadowBlur = 10; ctx.shadowColor = 'red';
                        ctx.beginPath();
                        ctx.moveTo(tx, -5); ctx.lineTo(tx - fSize, -5 - fSize);
                        ctx.lineTo(tx, -5 - fSize * 2); ctx.lineTo(tx + fSize, -5 - fSize);
                        ctx.fill();
                    };
                    drawTorch(-35); drawTorch(35);
                } else if (this.subType === 'ice') {
                    // V·∫Ω 2 ng∆∞·ªùi tuy·∫øt nh·ªè ·ªü 2 b√™n
                    const drawSnowman = (sx) => {
                        ctx.save();
                        ctx.translate(sx, 5);
                        const sBob = Math.sin(game.ticks * 0.05 + sx) * 1; // sx gi√∫p 2 ng∆∞·ªùi tuy·∫øt nh√∫n l·ªách nh·ªãp nhau ch√∫t cho t·ª± nhi√™n
                        ctx.fillStyle = 'white';
                        ctx.beginPath(); ctx.arc(0, 0 + sBob, 6, 0, Math.PI * 2); ctx.fill(); // Th√¢n
                        ctx.beginPath(); ctx.arc(0, -7 + sBob, 4, 0, Math.PI * 2); ctx.fill(); // ƒê·∫ßu
                        ctx.fillStyle = 'orange'; // M≈©i
                        ctx.fillRect(0, -8 + sBob, 3, 1);
                        ctx.fillStyle = '#2c3e50'; // M≈© nh·ªè
                        ctx.fillRect(-3, -11 + sBob, 6, 2);
                        ctx.restore();
                    };
                    drawSnowman(-35); drawSnowman(35);
                }
                ctx.restore();

                // Hi·ªáu ·ª©ng h·∫°t bay
                ctx.save();
                const pCount = 5;
                for (let i = 0; i < pCount; i++) {
                    const time = (game.ticks + i * 50) * 0.02;
                    const px = Math.cos(time) * (28 + i * 2);
                    const py = Math.sin(time * 0.5) * 40 - (25 + lv * 5);
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = this.subType === 'ice' ? '#ffffff' : '#ff9f43';
                    ctx.beginPath(); ctx.arc(px, py, 2, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
            }

            // --- 2. CH√ÇN ƒê·∫æ ---
            ctx.fillStyle = '#3e2723';
            ctx.beginPath(); ctx.roundRect(-28, 5, 56, 12, 4); ctx.fill();
            ctx.fillStyle = '#5d4037'; ctx.fillRect(-24, 0, 48, 8);

            // --- 3. TH√ÇN TH√ÅP ---
            ctx.fillStyle = '#7f8c8d'; ctx.fillRect(-22, -10, 44, 15); 
            ctx.fillStyle = lv === 3 ? '#5d4037' : '#8d6e63'; 
            ctx.fillRect(-18, -15 - lv*10, 36, 10 + lv*10); 

            if (lv >= 2) {
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(-22, -20 - lv*5, 6, 15); ctx.fillRect(16, -20 - lv*5, 6, 15);
            }

            // --- 4. M√ÅI TH√ÅP & NG·ªåC ƒê·ªàNH ---
            ctx.save();
            ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.fillStyle = this.subType === 'ice' ? '#81ecec' : (this.subType === 'fire' ? '#fab1a0' : (lv === 3 ? '#f1c40f' : lv === 2 ? '#c0392b' : '#d35400'));
            ctx.beginPath();
            ctx.moveTo(-30 - lv, -18 - lv*10); ctx.lineTo(30 + lv, -18 - lv*10); ctx.lineTo(0, -55 - lv*10);
            ctx.fill();
            ctx.restore();
            ctx.fillStyle = accent; ctx.fillRect(-24 - lv, -18 - lv*10, 48 + lv*2, 8);

            if (lv === 3 || this.subType) {
                ctx.fillStyle = accent;
                ctx.shadowBlur = 15; ctx.shadowColor = accent;
                ctx.beginPath(); ctx.arc(0, -58 - lv*10, 4, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }

            // --- 5. C·ªú HI·ªÜU (Level 3) ---
            if (lv === 3) {
                const flagWave = Math.sin(game.ticks * 0.1) * 5;
                ctx.fillStyle = accent;
                ctx.fillRect(-35, -35, 12, 8 + flagWave);
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(-23, -35); ctx.lineTo(-23, -20); ctx.stroke();
                ctx.fillRect(23, -35, 12, 8 + flagWave);
                ctx.beginPath(); ctx.moveTo(23, -35); ctx.lineTo(23, -20); ctx.stroke();
            }

            // --- 6. CUNG TH·ª¶ ---
            let progress = Math.min(1, this.timer / (this.fireRate / game.timeScale));
            let pull = progress > 0.6 ? (progress - 0.6) * 15 : 0;
            const archerCount = (lv === 3) ? 2 : 1;
            for (let i = 0; i < archerCount; i++) {
                ctx.save();
                let offsetX = (lv === 3) ? (i === 0 ? -12 : 12) : 0;
                ctx.translate(offsetX, -24 - lv * 10);
                ctx.scale(this.archerFacing, 1);
                ctx.fillStyle = this.subType === 'ice' ? '#3498db' : (this.subType === 'fire' ? '#c0392b' : '#a0522d');
                ctx.beginPath(); ctx.roundRect(-5, -5, 10, 14, 2); ctx.fill();
                ctx.fillStyle = '#ffe0bd'; ctx.beginPath(); ctx.arc(0, -10, 5, 0, Math.PI * 2); ctx.fill();
                if (lv === 3) {
                    ctx.fillStyle = accent;
                    ctx.beginPath(); ctx.moveTo(-2, -14); ctx.lineTo(2, -14); ctx.lineTo(0, -20); ctx.fill();
                }
                ctx.strokeStyle = this.subType === 'fire' ? '#e67e22' : (this.subType === 'ice' ? '#00d2ff' : '#5d4037');
                if (this.subType) { ctx.shadowBlur = 15; ctx.shadowColor = ctx.strokeStyle; }
                ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(5 - (pull * 0.15), -10); ctx.quadraticCurveTo(13 - (pull * 0.15), 0, 5 - (pull * 0.15), 10);
                ctx.stroke();
                ctx.restore();
            }

            // --- 7. L·ªúI THO·∫†I ---
            if (this.barkLife > 0) {
                ctx.save(); ctx.font = "bold 10px Segoe UI";
                const tw = ctx.measureText(this.barkText).width;
                ctx.fillStyle = "white"; ctx.beginPath();
                ctx.roundRect(-tw/2-5, -75-lv*10, tw+10, 16, 4);
                ctx.fill(); ctx.stroke();
                ctx.fillStyle="black"; ctx.textAlign="center";
                ctx.fillText(this.barkText, 0, -64-lv*10);
                ctx.restore();
            }
        } else if (this.type === 'mage') {
            const themeColor = lv === 1 ? '#3498db' : lv === 2 ? '#f39c12' : '#bf00ff';
            const bodyColor = lv === 1 ? '#1a2a3a' : lv === 2 ? '#3a2a1a' : '#1a1a1a';
            const pulse = Math.sin(game.ticks * 0.1);
            const glowVal = 0.5 + pulse * 0.4;
            const floatY = Math.sin(game.ticks * 0.05) * 6;
            const crystalCenterY = -75 - lv * 10 + floatY; // T√¢m c·ªßa qu·∫£ c·∫ßu th·ªßy tinh

            // --- 1. V√íNG TR√íN PH√âP THU·∫¨T D∆Ø·ªöI CH√ÇN (CH·ªà LEVEL 3) ---
            if (lv === 3) {
                ctx.save();
                ctx.translate(0, 10);
                ctx.strokeStyle = themeColor;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.4 + pulse * 0.2;
                ctx.shadowBlur = 15;
                ctx.shadowColor = themeColor;
                ctx.save();
                ctx.rotate(game.ticks * 0.02);
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2);
                ctx.stroke();
                for (let i = 0; i < 8; i++) {
                    ctx.rotate(Math.PI / 4);
                    ctx.beginPath(); ctx.moveTo(30, 0); ctx.lineTo(38, 0); ctx.stroke();
                }
                ctx.restore();
                const waveScale = (game.ticks % 60) / 60;
                ctx.globalAlpha = (1 - waveScale) * 0.3;
                ctx.beginPath(); ctx.arc(0, 0, 20 + waveScale * 40, 0, Math.PI * 2); ctx.stroke();
                ctx.restore();
            }

            // --- 2. H√åNH D√ÅNG TR·ª§ G·ªêC ---
            ctx.fillStyle = bodyColor; 
            ctx.beginPath(); 
            ctx.moveTo(-16 - lv, 10); ctx.lineTo(16 + lv, 10); 
            ctx.lineTo(8 + lv, -45 - lv * 5); ctx.lineTo(-8 - lv, -45 - lv * 5); 
            ctx.closePath(); ctx.fill();

            ctx.save();
            ctx.strokeStyle = themeColor; ctx.globalAlpha = glowVal; ctx.lineWidth = 2 + lv * 0.5; 
            ctx.shadowBlur = 15; ctx.shadowColor = themeColor;
            ctx.beginPath(); ctx.moveTo(-5, 5); ctx.lineTo(-3, -40 - lv * 5); ctx.stroke(); 
            ctx.beginPath(); ctx.moveTo(5, 5); ctx.lineTo(3, -40 - lv * 5); ctx.stroke();
            ctx.restore();

            // --- 3. H√ÄM V·∫º PH√ô TH·ª¶Y & TIA S√âT K·∫æT N·ªêI ---
            const drawWizardWithLightning = (side, heightPos, color, hatColor, offsetPhase) => {
                ctx.save();
                const isLeft = side === 'left';
                const dir = isLeft ? -1 : 1;
                const wizX = (heightPos === 'top' ? 16 : 24) * dir;
                const wizY = heightPos === 'top' ? -35 : 0; 
                const wizBob = Math.sin(game.ticks * 0.1 + offsetPhase) * 2; 

                // T·ªça ƒë·ªô ƒë·∫ßu g·∫≠y ph√©p
                const staffTopX = wizX + (7 * dir);
                const staffTopY = wizY - 21 + wizBob;

                // V·∫Ω b·∫≠c ƒë√°
                ctx.fillStyle = bodyColor;
                ctx.beginPath(); ctx.roundRect(wizX - (isLeft ? 8 : 7), wizY + 2, 15, 5, 2); ctx.fill();
                ctx.strokeStyle = themeColor; ctx.stroke();

                // V·∫Ω tia s√©t k·∫øt n·ªëi v√†o qu·∫£ c·∫ßu (Ch·ªâ t·∫ßng tr√™n ho·∫∑c t·∫•t c·∫£ t√πy ch·ªçn)
                if (lv >= 2) {
                    ctx.save();
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.6 + pulse * 0.4;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = themeColor;
                    
                    ctx.beginPath();
                    ctx.moveTo(staffTopX, staffTopY);
                    
                    // V·∫Ω ƒë∆∞·ªùng ziczac ng·∫´u nhi√™n t·∫°o hi·ªáu ·ª©ng s√©t
                    let steps = 4;
                    for(let i = 1; i <= steps; i++) {
                        let tx = staffTopX + (0 - staffTopX) * (i / steps) + (Math.random() - 0.5) * 8;
                        let ty = staffTopY + (crystalCenterY - staffTopY) * (i / steps) + (Math.random() - 0.5) * 8;
                        ctx.lineTo(tx, ty);
                    }
                    ctx.lineTo(0, crystalCenterY);
                    ctx.stroke();
                    ctx.restore();
                }

                // Nh√¢n v·∫≠t ph√π th·ªßy
                ctx.fillStyle = color;
                ctx.beginPath(); ctx.moveTo(wizX - 5, wizY); ctx.lineTo(wizX + 5, wizY); ctx.lineTo(wizX, wizY - 15 + wizBob); ctx.fill();
                ctx.fillStyle = '#ffe0bd';
                ctx.beginPath(); ctx.arc(wizX, wizY - 16 + wizBob, 3, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = hatColor;
                ctx.beginPath(); ctx.moveTo(wizX - 4, wizY - 18 + wizBob); ctx.lineTo(wizX + 4, wizY - 18 + wizBob); ctx.lineTo(wizX, wizY - 28 + wizBob); ctx.fill();

                // G·∫≠y ph√©p
                ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(wizX + (4 * dir), wizY); ctx.lineTo(staffTopX, staffTopY + 1); ctx.stroke();
                ctx.fillStyle = themeColor; ctx.shadowBlur = 10; ctx.shadowColor = themeColor;
                ctx.beginPath(); ctx.arc(staffTopX, staffTopY, 2.5, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            };

            if (lv >= 2) {
                drawWizardWithLightning('left', 'top', '#2980b9', '#f39c12', 0);
                drawWizardWithLightning('right', 'top', '#2980b9', '#f39c12', Math.PI);
            }
            if (lv === 3) {
                drawWizardWithLightning('left', 'bottom', '#4b0082', '#a55eea', Math.PI / 2);
                drawWizardWithLightning('right', 'bottom', '#4b0082', '#a55eea', -Math.PI / 2);
            }

            // --- 4. V·∫¨T TH·ªÇ BAY XUNG QUANH ---
            ctx.save();
            ctx.translate(0, -20);
            ctx.rotate(Math.PI / 2);
            ctx.strokeStyle = themeColor; ctx.lineWidth = 1; ctx.globalAlpha = 0.2 * glowVal;
            for(let i = 0; i < 2; i++) {
                ctx.save();
                ctx.rotate(game.ticks * 0.02 * (i === 0 ? 1 : -1));
                ctx.beginPath(); ctx.ellipse(0, 0, 15 + i * 10, 32 + lv * 6, 0, 0, Math.PI * 2); ctx.stroke();
                ctx.restore();
            }
            ctx.restore();

            // --- 5. TINH TH·ªÇ ƒê·ªàNH TH√ÅP ---
            const drawCrystal = (ox, oy, size, color) => { 
                ctx.save(); ctx.translate(ox, oy); ctx.rotate(game.ticks * 0.02); 
                ctx.fillStyle = color; ctx.shadowBlur = 12; ctx.shadowColor = color; 
                ctx.beginPath(); ctx.moveTo(0, -size); ctx.lineTo(size * 0.7, 0); ctx.lineTo(0, size); ctx.lineTo(-size * 0.7, 0); 
                ctx.closePath(); ctx.fill(); 
                ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.beginPath(); ctx.arc(-size * 0.2, -size * 0.2, size * 0.2, 0, Math.PI * 2); ctx.fill(); 
                ctx.restore(); 
            };

            drawCrystal(0, crystalCenterY, 8 + lv * 2, '#00d2ff');
            const count = lv * 2; 
            for(let i=0; i < count; i++) { 
                const angle = (game.ticks * 0.04) + (i / count) * Math.PI * 2; 
                const dist = 22 + lv * 5; 
                const cx = Math.cos(angle) * dist; 
                const cy = crystalCenterY + Math.sin(angle * 1.5) * 10; 
                drawCrystal(cx, cy, 4 + lv, i % 2 === 0 ? '#bf00ff' : '#00d2ff'); 
            }
        }
        else if (this.type === 'barracks') {
            const sub = this.subType;
            const lv = this.level;

            // 1. CH√ÇN ƒê·∫æ ƒê√Å T·∫¢NG (ƒê·ªì s·ªô & V·ªØng ch√£i)
            ctx.fillStyle = '#3e2723'; ctx.beginPath(); ctx.roundRect(-32, 0, 64, 15, 2); ctx.fill(); 
            ctx.fillStyle = '#5d4037'; ctx.beginPath(); ctx.roundRect(-30, -5, 60, 15, 2); ctx.fill(); 

            // 2. TH√ÇN TH√ÅP CH√çNH (K·∫øt c·∫•u ƒë√° c≈© k·ªπ)
            ctx.fillStyle = sub === 'holy' ? '#bdc3c7' : (sub === 'barb' ? '#2c1e1a' : '#5d5d5d');
            ctx.beginPath(); ctx.roundRect(-24, -25 - lv*5, 48, 25 + lv*5, 2); ctx.fill();
            
            // C√°c v·∫øt n·ª©t th·ªùi gian
            ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1;
            for(let i=0; i<3; i++) {
                ctx.beginPath(); 
                ctx.moveTo(-15 + i * 15, -10); ctx.lineTo(-5 + i * 15, -12); 
                ctx.stroke();
            }

            // --- ƒê√àN L·ªíNG TREO HI√äN ƒêUNG ƒê∆ØA ---
            const drawLantern = (lx, ly) => {
                const swing = Math.sin(game.ticks * 0.05) * 2;
                ctx.save(); ctx.translate(lx, ly);
                ctx.strokeStyle = '#2d1d1a'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(swing, 8); ctx.stroke();
                ctx.translate(swing, 8);
                ctx.fillStyle = '#3e2723'; ctx.fillRect(-3, 0, 6, 8);
                ctx.fillStyle = sub === 'holy' ? '#fff' : '#f1c40f';
                ctx.shadowBlur = 8; ctx.shadowColor = ctx.fillStyle;
                ctx.fillRect(-2, 1, 4, 5); ctx.restore();
            };
            drawLantern(-20, -25 - lv*5); drawLantern(20, -25 - lv*5);

            // 3. C·ª¨A V√íM ƒê√Å (N∆°i l√≠nh xu·∫•t qu√¢n)
            ctx.fillStyle = '#1a1a1a'; ctx.beginPath(); ctx.roundRect(-10, -14, 20, 14, 5); ctx.fill();

            // 4. TH√ÅP CANH & C·ªú HI·ªÜU (X√¢y th√™m t·ª´ Level 2)
            if (lv >= 2) {
                // Th√°p ph·ª• hai b√™n
                ctx.fillStyle = sub === 'holy' ? '#95a5a6' : (sub === 'barb' ? '#1a1a1a' : '#424242');
                ctx.fillRect(-36, -25, 12, 25); ctx.fillRect(24, -25, 12, 25);
                
                // --- H·ªÜ TH·ªêNG 2 L√Å C·ªú TR∆†N BAY PH·∫§P PH·ªöI ---
                const drawBanner = (bx, by, side) => {
                    const wave = Math.sin(game.ticks * 0.08 + bx) * 5;
                    const bannerColor = sub === 'holy' ? '#f1c40f' : (sub === 'barb' ? '#c0392b' : '#3498db');
                    
                    ctx.save();
                    ctx.translate(bx, by);
                    
                    // C√°n c·ªù g·ªó
                    ctx.strokeStyle = '#3e2723'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -22); ctx.stroke();
                    
                    // V·∫£i c·ªù tr∆°n chuy·ªÉn ƒë·ªông (ƒê√£ lo·∫°i b·ªè h√¨nh v·∫Ω)
                    ctx.fillStyle = bannerColor;
                    ctx.beginPath();
                    ctx.moveTo(0, -22);
                    ctx.quadraticCurveTo(10 * side, -22 + wave, 20 * side, -22);
                    ctx.lineTo(20 * side, -8);
                    ctx.quadraticCurveTo(10 * side, -8 + wave, 0, -8);
                    ctx.fill();
                    
                    ctx.restore();
                };
                
                drawBanner(-30, -25, -1); 
                drawBanner(30, -25, 1);

                // M√°i th√°p canh
                ctx.fillStyle = sub === 'holy' ? '#2980b9' : (sub === 'barb' ? '#c0392b' : '#3e2723');
                ctx.beginPath(); ctx.moveTo(-40, -25); ctx.lineTo(-20, -25); ctx.lineTo(-30, -40); ctx.fill();
                ctx.beginPath(); ctx.moveTo(40, -25); ctx.lineTo(20, -25); ctx.lineTo(30, -40); ctx.fill();
                drawLantern(-30, -25); drawLantern(30, -25);
            }

            // 5. M√ÅI NH√Ä & CHI TI·∫æT ƒê·∫∂C TR∆ØNG LEVEL 3
            if (lv === 3) {
                if (sub === 'holy') { 
                    ctx.fillStyle = '#3498db'; ctx.fillRect(-22, -55, 18, 12); ctx.fillRect(4, -55, 18, 12); 
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, -35, 6, 0, Math.PI*2); ctx.fill(); 
                } else { 
                    ctx.fillStyle = '#7f0000'; ctx.beginPath(); ctx.moveTo(-22, -48); ctx.lineTo(-2, -43); ctx.lineTo(-22, -38); ctx.fill(); 
                    ctx.strokeStyle = '#dcdde1'; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.moveTo(-18, -25); ctx.quadraticCurveTo(-35, -45, -25, -60); ctx.stroke(); 
                    ctx.beginPath(); ctx.moveTo(18, -25); ctx.quadraticCurveTo(35, -45, 25, -60); ctx.stroke(); 
                }
            } else { 
                // M√°i nh√† g·ªó ch·ªìng l·ªõp d√†y d·∫∑n (C·∫•p 1 & 2)
                ctx.fillStyle = '#3e2723'; 
                ctx.beginPath(); ctx.moveTo(-28, -25 - lv*5); ctx.lineTo(28, -25 - lv*5); ctx.lineTo(0, -50 - lv*5); ctx.fill();
                ctx.fillStyle = '#4e342e'; 
                ctx.beginPath(); ctx.moveTo(-22, -28 - lv*5); ctx.lineTo(22, -28 - lv*5); ctx.lineTo(0, -46 - lv*5); ctx.fill();
            }
        }else if (this.type === 'artillery') {
            const lv = this.level;
            const themeColor = lv === 3 ? '#e74c3c' : '#7f8c8d';

            // 1. V·∫Ω ch√¢n ƒë·∫ø (Platform)
            ctx.fillStyle = '#3e2723'; 
            ctx.beginPath();
            ctx.arc(0, 0, 26 + lv * 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#2d1d1a';
            ctx.lineWidth = 3;
            ctx.stroke();

            // 2. V·∫Ω 4 n·ªët tr√≤n trang tr√≠ (L·ªõp d∆∞·ªõi)
            if (lv >= 2) {
                ctx.save();
                ctx.fillStyle = '#d35400'; 
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#d35400';
                const dist = 18 + lv;
                ctx.beginPath(); ctx.arc(-dist, -dist, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(dist, -dist, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(-dist, dist, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(dist, dist, 5, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }

            // Hi·ªáu ·ª©ng h·∫°t l·ª≠a bay l√™n (Lv 2 & 3)
            if (lv >= 2 && Math.random() < 0.15 * game.timeScale) {
                game.particles.push(new Particle(this.x + (Math.random()-0.5)*30, this.y - 10, '#e67e22', (Math.random()-0.5), -2, 30));
            }

            // 3. Ph·∫ßn b·ªá xoay, N√≤ng ph√°o v√† L√çNH G√ÅC
            ctx.save();
            ctx.rotate(this.angle);
            ctx.translate(-this.recoil, 0); 

            // --- V·∫º NG∆Ø·ªúI L√çNH G√ÅC (GUNNER) ---
            ctx.save();
            // V·ªã tr√≠ ng∆∞·ªùi l√≠nh ƒë·ª©ng l√πi v·ªÅ ph√≠a sau ƒëu√¥i ph√°o m·ªôt ch√∫t
            ctx.translate(-15, -12); 
            const bob = Math.sin(game.ticks * 0.1) * 2; // Hi·ªáu ·ª©ng nh·∫•p nh√¥

            // Th√¢n ng∆∞·ªùi l√≠nh
            ctx.fillStyle = lv === 3 ? '#1a1a1a' : (lv === 2 ? '#2980b9' : '#5d4037');
            ctx.beginPath();
            ctx.roundRect(-5, -5 + bob, 10, 12, 2);
            ctx.fill();

            // ƒê·∫ßu v√† M≈©
            ctx.fillStyle = '#ffe0bd'; // Da m·∫∑t
            ctx.beginPath(); ctx.arc(0, -8 + bob, 4, 0, Math.PI * 2); ctx.fill();
            
            // M≈© s·∫Øt (Ng·∫ßu h∆°n theo level)
            ctx.fillStyle = lv === 3 ? '#c0392b' : '#7f8c8d'; 
            ctx.beginPath();
            if (lv === 3) {
                // M≈© chi·∫øn binh c√≥ s·ª´ng/m√†o ƒë·ªè
                ctx.arc(0, -10 + bob, 5, Math.PI, 0);
                ctx.moveTo(0, -15 + bob); ctx.lineTo(0, -22 + bob); // M√†o m≈©
            } else {
                ctx.arc(0, -10 + bob, 5, Math.PI, 0); // M≈© c·ªëi ƒë∆°n gi·∫£n
            }
            ctx.fill();

            // Tay c·∫ßm c·∫ßn g·∫°t (Level 2 & 3)
            if (lv >= 2) {
                ctx.strokeStyle = '#3e2723';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(4, 0 + bob); ctx.lineTo(12, -5); ctx.stroke();
                ctx.fillStyle = '#d35400';
                ctx.beginPath(); ctx.arc(12, -5, 2, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();

            // 4. V·∫Ω n√≤ng ph√°o (ƒê√® l√™n tay ng∆∞·ªùi l√≠nh)
            ctx.fillStyle = lv === 3 ? '#1a1a1a' : '#2c3e50'; 
            if (lv === 3) {
                ctx.fillRect(0, -15, 48, 12);
                ctx.fillStyle = '#e74c3c'; ctx.fillRect(40, -15, 8, 12);
                ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 3, 48, 12);
                ctx.fillStyle = '#e74c3c'; ctx.fillRect(40, 3, 8, 12);
                ctx.fillStyle = '#34495e'; ctx.fillRect(-5, -12, 18, 24);
            } else {
                ctx.fillRect(-5, -12, 15, 24);
                ctx.beginPath();
                ctx.moveTo(5, -10); ctx.lineTo(35 + lv * 5, -14);
                ctx.lineTo(35 + lv * 5, 14); ctx.lineTo(5, 10);
                ctx.fill();
                ctx.fillStyle = '#95a5a6';
                ctx.fillRect(15 + lv*2, -13, 6, 26);
            }

            // ƒêu√¥i ph√°o
            ctx.fillStyle = '#34495e';
            ctx.beginPath(); ctx.arc(-8, 0, 10, 0, Math.PI * 2); ctx.fill();

            ctx.restore();
        }
        // V·∫Ω ch·ªØ LV
        ctx.fillStyle = 'white'; ctx.font = 'bold 12px Segoe UI'; ctx.textAlign = "center";
        ctx.strokeText("LV" + lv, 0, 35); ctx.fillText("LV" + lv, 0, 35);

        ctx.restore(); // Kh√¥i ph·ª•c t·ªça ƒë·ªô v·ªÅ m·∫∑c ƒë·ªãnh c·ªßa to√†n b·∫£n ƒë·ªì

        // 3. V·∫º BINH L√çNH (V·∫Ω SAU C√ôNG ƒë·ªÉ n·∫±m TR√äN th√°p)
        if (this.type === 'barracks') {
            this.soldiers.forEach(s => s.draw(ctx)); 
        }
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d'); this.setupCanvas();
        this.sessionID = 0;
        this.waves = [
            { c: 15, t: 'GOBLIN', r: 50 }, { c: 25, t: 'GOBLIN', r: 40 }, { c: 20, t: 'ORC', r: 80 }, { c: 30, t: 'RUNNER', r: 25 },
            { c: 25, t: 'ARMORED', r: 100 }, { c: 12, t: 'FLYING', r: 60 }, 
            { c: 30, types: ['GOBLIN', 'GOBLIN', 'ORC', 'ORC', 'RUNNER', 'FLYING'], r: 15 }, 
            { c: 20, types: ['SHAMAN', 'SHAMAN', 'ARMORED', 'ARMORED', 'SHAMAN', 'ARMORED', 'FLYING', 'FLYING', 'SHAMAN'], r: 100 },    
            { c: 25, types: ['ORC', 'ORC', 'RUNNER', 'RUNNER', 'ARMORED', 'ARMORED', 'ORC', 'RUNNER', 'ARMORED', 'FLYING', 'FLYING', 'ORC'], r: 60 }, 
            { c: 30, types: ['ARMORED', 'ARMORED', 'SHAMAN', 'SHAMAN', 'TANK', 'TANK', 'ARMORED', 'SHAMAN', 'TANK', 'FLYING', 'FLYING', 'TANK'], r: 60 }, 
            { c: 15, t: 'TANK', r: 150 }, 
            { c: 3, t: 'BOSS', r: 200 }
        ];
        // --- STRICT MASTER TUTORIAL STEPS ---
        this.tutorialSteps = [
            { msg: "Ch√†o m·ª´ng B·ªá h·∫°! H√£y b·∫£o v·ªá v∆∞∆°ng qu·ªëc.", condition: "next", strict: false },
            { msg: "ƒê√¢y l√† s·ªë ti·ªÅn b·∫°n ƒëang c√≥. H√£y d√πng n√≥ ƒë·ªÉ x√¢y d·ª±ng th√°p!", condition: "gold", arrow: {x: 130, y: 22, dir: 'left'}, strict: false },
            { msg: "V√† ƒë√¢y l√† s·ªë m·∫°ng c√≤n l·∫°i. N·∫øu v·ªÅ 0, V∆∞∆°ng qu·ªëc s·∫Ω s·ª•p ƒë·ªï!", condition: "lives", arrow: {x: 130, y: 52, dir: 'left'}, strict: false },
            { msg: "Click v√†o √¥ tr√≤n x√°m n√†y ƒë·ªÉ m·ªü menu x√¢y d·ª±ng.", condition: "pad", arrow: {x: BUILD_PADS[0].x, y: BUILD_PADS[0].y - 35, dir: 'down'}, strict: true },
            { msg: "Ch·ªçn bi·ªÉu t∆∞·ª£ng Barracks (üõ°Ô∏è) ƒë·ªÉ ch·∫∑n qu√¢n th√π.", condition: "barracks", menuArrow: {x: 0, y: 55}, strict: true },
            { msg: "Binh l√≠nh ƒë√£ s·∫µn s√†ng! Click v√†o th√°p ƒë·ªÉ ƒëi·ªÅu l·ªánh.", condition: "select_barracks", arrow: {x: BUILD_PADS[0].x, y: BUILD_PADS[0].y - 35, dir: 'down'}, strict: true },
            { msg: "Nh·∫•n v√†o l√° c·ªù (üö©) ƒë·ªÉ thay ƒë·ªïi v·ªã tr√≠ t·∫≠p k·∫øt qu√¢n.", condition: "rally_btn", menuArrow: {x: 65, y: 0}, strict: true },
            { msg: "Click v√†o m·ªôt ƒëi·ªÉm tr√™n ƒë∆∞·ªùng ƒë·ªÉ l√≠nh di chuy·ªÉn ra ƒë√≥.", condition: "rally_click", groundArrow: {x: 120, y: 300}, strict: true },
            { msg: "R·∫•t t·ªët! Gi·ªù h√£y click v√†o √¥ ƒë·∫•t k·∫ø b√™n...", condition: "pad2", arrow: {x: BUILD_PADS[1].x, y: BUILD_PADS[1].y - 35, dir: 'down'}, strict: true },
            { msg: "Ch·ªçn bi·ªÉu t∆∞·ª£ng Archer (üèπ) ƒë·ªÉ ti√™u di·ªát ch√∫ng t·ª´ xa.", condition: "archer", menuArrow: {x: 0, y: -75}, strict: true },
            { msg: "K√≠ch ho·∫°t chi√™u M∆∞a L·ª≠a b·∫±ng c√°ch click v√†o bi·ªÉu t∆∞·ª£ng n√†y!", condition: "skill_q", arrow: {x: 45, y: CONFIG.HEIGHT - 75, dir: 'down'}, strict: true },
            { msg: "Qu√¢n ƒë·ªãch h·∫°ng n·∫∑ng ƒë√£ xu·∫•t hi·ªán! H√£y tung chi√™u ƒë·ªÉ ti√™u di·ªát ch√∫ng.", condition: "combat", groundArrow: {x: 180, y: 300}, strict: true },
            { msg: "B·ªá h·∫° c≈©ng c√≥ th·ªÉ g·ªçi l√≠nh n√¥ng d√¢n tr·ª£ chi·∫øn b·∫±ng c√°ch nh·∫•n v√†o ƒë√¢y (W)!", condition: "skill_w", arrow: {x: 120, y: CONFIG.HEIGHT - 75, dir: 'down'}, strict: true },
            { msg: "H√£y ƒë·∫∑t l√≠nh n√¥ng d√¢n ra ƒë∆∞·ªùng ƒë·ªÉ h·ªó tr·ª£ qu√¢n l√≠nh.", condition: "militia", groundArrow: {x: 220, y: 300}, strict: true },
            { msg: "V√† ƒë·ª´ng qu√™n ƒëi·ªÅu khi·ªÉn Anh H√πng c·ªßa m√¨nh! Nh·∫•n v√†o ƒë√¥i gi√†y (R).", condition: "skill_r", arrow: {x: 270, y: CONFIG.HEIGHT - 75, dir: 'down'}, strict: true },
            { msg: "Click v√†o v·ªã tr√≠ g·∫ßn qu√°i v·∫≠t ƒë·ªÉ Anh H√πng ra tr·∫≠n chi·∫øn ƒë·∫•u.", condition: "hero_move", groundArrow: {x: 800, y: 250}, strict: true },
            { msg: "Anh H√πng c√≥ k·ªπ nƒÉng d·∫≠m ƒë·∫•t (E) c·ª±c m·∫°nh! H√£y nh·∫•n v√†o bi·ªÉu t∆∞·ª£ng tia s√©t ƒë·ªÉ thi tri·ªÉn.", condition: "skill_e", arrow: {x: 185, y: CONFIG.HEIGHT - 75, dir: 'down'}, strict: true },
            { msg: "Ho√†n t·∫•t hu·∫•n luy·ªán! H√£y nh·∫•n TI·∫æP T·ª§C ƒë·ªÉ v√†o cu·ªôc chi·∫øn th·∫≠t s·ª±.", condition: "done", strict: false }
        ];
        this.tutorialIndex = 0;
        this.inTutorial = true;
        this.restart(); this.bindEvents();
    }
    setupCanvas() { const dpr = window.devicePixelRatio || 1; this.canvas.width = CONFIG.WIDTH*dpr; this.canvas.height = CONFIG.HEIGHT*dpr; this.canvas.style.width = CONFIG.WIDTH+'px'; this.canvas.style.height = CONFIG.HEIGHT+'px'; this.ctx.scale(dpr, dpr); }
    shake(intensity) { this.shakeIntensity = Math.max(this.shakeIntensity, intensity); }
    restart() {
        this.fireAreas = [];
        this.sessionID++; this.gold = CONFIG.INITIAL_GOLD; this.lives = CONFIG.INITIAL_LIVES; this.waveIdx = 0;
        this.enemies = []; this.towers = []; this.projectiles = []; this.effects = []; this.meteors = []; this.militia = []; this.floatingTexts = []; this.splats = []; this.particles = [];
        this.hero = new Hero(); this.timeScale = 1; this.isPaused = false; this.spawning = false; this.waveTimer = 0; this.skillCDs = { RAIN: 0, REINFORCE: 0, HERO: 0, MOVE: 0 };
        this.isRallying = false; this.isHeroMoveMode = false; this.selectedTower = null; this.ticks = 0; this.shakeIntensity = 0; this.skillMode = null;
        document.querySelectorAll('.cooldown-overlay').forEach(el => el.style.height = '0%');
        document.getElementById('msg-overlay').style.display = 'none'; document.getElementById('wave-btn').style.display = 'block';
        document.getElementById('wave-btn').style.display = this.inTutorial ? 'none' : 'block';
        document.getElementById('pause-indicator').style.display = 'none'; document.getElementById('skill-cancel').style.display = 'none';
        document.getElementById('speed-btn').innerText = '‚è© 1x'; this.hideMenus();
        if (this.inTutorial) { this.gold = 600; this.tutorialIndex = 0; this.showTutorialMessage(); }
    }

    showTutorialMessage() {
        const overlay = document.getElementById('tutorial-overlay');
        const nextBtn = document.getElementById('tutorial-next');
        const arrowDom = document.getElementById('tutorial-arrow-dom');
        const step = this.tutorialSteps[this.tutorialIndex];
        overlay.style.display = 'block';
        document.getElementById('tutorial-msg').innerText = step.msg;
        nextBtn.style.display = step.strict ? 'none' : 'inline-block';
        
        // C·∫≠p nh·∫≠t m≈©i t√™n DOM HTML
        if (step.arrow) {
            arrowDom.style.display = 'block';
            const dir = step.arrow.dir || 'down';
            arrowDom.className = 'point-' + dir;
            
            if (dir === 'left') {
                arrowDom.style.left = step.arrow.x + 'px';
                arrowDom.style.top = (step.arrow.y - 15) + 'px';
            } else {
                arrowDom.style.left = (step.arrow.x - 15) + 'px';
                arrowDom.style.top = (step.arrow.y - 30) + 'px';
            }
        } else { arrowDom.style.display = 'none'; }
    }
    advanceTutorial() {
    if (this.tutorialIndex < this.tutorialSteps.length - 1) {
        this.tutorialIndex++; 
        this.showTutorialMessage();
        const step = this.tutorialSteps[this.tutorialIndex];
        
        if (step.condition === "select_barracks") {
            this.spawnTutorialEnemies();
            this.spawnTankyTutorialEnemies();
        }
        
        if (step.condition === "combat") this.spawnTankyTutorialEnemies();
    } else { 
        // Thay v√¨ g·ªçi this.skipTutorial(), ta chuy·ªÉn h∆∞·ªõng th·∫≥ng v·ªÅ menu
        window.location.href = 'menu.html'; 
        }
    }

    skipTutorial() { 
        // Khi ng∆∞·ªùi ch∆°i nh·∫•n n√∫t B·ªè qua h∆∞·ªõng d·∫´n
        window.location.href = 'menu.html'; 
    }
    spawnTutorialEnemies() { for(let i=0; i<8; i++) { setTimeout(() => { if (this.inTutorial) this.enemies.push(new Enemy('GOBLIN')); }, i * 1500); } }
    // Spawn qu√°i v·∫≠t thi·∫øt gi√°p tr√¢u b√≤ ƒë·ªÉ ch·ª©ng minh th√°p v·∫≠t l√Ω ko c·∫£n n·ªïi
    spawnTankyTutorialEnemies() {
        for(let i=0; i<4; i++) {
            setTimeout(() => {
                if (this.inTutorial) {
                    const e = new Enemy('ARMORED');
                    e.hp = 1500; // L√†m tr√¢u h∆°n n·ªØa ƒë·ªÉ th√°p v·∫≠t l√Ω v√† l√≠nh ko gi·∫øt n·ªïi
                    this.enemies.push(e);
                }
            }, 3000 + (i * 1200)); // Cho b·ªçn n√†y ƒëi sau l≈© Goblins m·ªôt ch√∫t
        }
    }
    // skipTutorial() { this.inTutorial = false; document.getElementById('tutorial-overlay').style.display = 'none'; document.getElementById('tutorial-arrow-dom').style.display = 'none'; this.restart(); document.getElementById('wave-btn').style.display = 'block'; }

    async nextWave() {
        if (this.isPaused || this.spawning) return;
        const sid = this.sessionID; document.getElementById('wave-btn').style.display = 'none';
        const bonus = Math.floor(this.waveTimer / 60) * 2;
        if (bonus > 0) { this.gold += bonus; Sound.coin(); this.floatingTexts.push(new FloatingText(CONFIG.WIDTH-150, 40, `+${bonus} V√ÄNG`, "#f1c40f", 20, true)); }
        if (this.waveIdx >= this.waves.length) return;
        const w = this.waves[this.waveIdx++]; this.spawning = true; this.waveTimer = 0;
        for(let i=0; i<w.c; i++) { 
            if (this.sessionID !== sid) return; 
            while(this.isPaused) { if (this.sessionID !== sid) return; await new Promise(r => setTimeout(r, 100)); } 
            const type = w.types ? w.types[Math.floor(Math.random() * w.types.length)] : w.t;
            this.enemies.push(new Enemy(type)); 
            await new Promise(r => setTimeout(r, (w.r * 10) / this.timeScale)); 
        }
        this.spawning = false; this.waveTimer = 1800;
    }
    toggleSpeed() { if (this.isPaused) return; this.timeScale = (this.timeScale === 1) ? 2 : 1; document.getElementById('speed-btn').innerText = (this.timeScale === 1) ? '‚è© 1x' : '‚è© 2x'; }
    cancelActiveModes(e) { if (e) e.stopPropagation(); this.skillMode = null; this.isHeroMoveMode = false; this.isRallying = false; if (this.hero) this.hero.selected = false; document.getElementById('instruction-text').style.display = 'none'; document.getElementById('skill-cancel').style.display = 'none'; document.querySelectorAll('.skill-btn').forEach(b => b.classList.remove('active')); }
    selectSkill(type) { 
        if (this.isPaused || this.skillCDs[type] > 0) return; 
        this.cancelActiveModes(); this.skillMode = type; 
        document.getElementById('instruction-text').innerText = "CH·ªåN V·ªä TR√ç K·ª∏ NƒÇNG"; document.getElementById('instruction-text').style.display = 'block'; document.getElementById('skill-cancel').style.display = 'flex'; document.getElementById(`skill-${type.toLowerCase()}`).classList.add('active'); 
        // --- TUTORIAL TRIGGERS ---
        if (this.inTutorial) {
            const step = this.tutorialSteps[this.tutorialIndex];
            if (type === 'RAIN' && step.condition === "skill_q") this.advanceTutorial();
            else if (type === 'REINFORCE' && step.condition === "skill_w") this.advanceTutorial();
        }
    }
    selectHeroMove() { 
        if (this.isPaused) return; this.cancelActiveModes(); this.isHeroMoveMode = true; this.hero.selected = true; document.getElementById('instruction-text').innerText = "DI CHUY·ªÇN ANH H√ôNG"; document.getElementById('instruction-text').style.display = 'block'; document.getElementById('skill-cancel').style.display = 'flex'; document.getElementById('skill-move').classList.add('active'); Sound.heroSelect(); this.hero.bark(this.hero.barksSelect[Math.floor(Math.random()*this.hero.barksSelect.length)]); 
        
        // --- TUTORIAL TRIGGER ---
        if (this.inTutorial && this.tutorialSteps[this.tutorialIndex].condition === "skill_r") this.advanceTutorial();
    }
    useHeroSkill() { 
        if (this.isPaused || this.skillCDs.HERO > 0 || this.hero.isDead) return; 
        this.cancelActiveModes(); 
        this.hero.bark("DEMICIA!"); Sound.slam(); this.shake(15); 
        this.effects.push({x:this.hero.x, y:this.hero.y, life:30, maxLife:30, color:'rgba(155, 89, 182, 0.6)', r:CONFIG.SKILLS.HERO_SLAM.radius}); 
        this.enemies.forEach(e => { if (Math.sqrt((e.x-this.hero.x)**2 + (e.y-this.hero.y)**2) < CONFIG.SKILLS.HERO_SLAM.radius) { e.takeDamage(CONFIG.SKILLS.HERO_SLAM.damage, 'phys', true); if (!e.flying) e.stunned = 100; } }); 
        this.skillCDs.HERO = CONFIG.SKILLS.HERO_SLAM.cd * 60; 

        // K√≠ch ho·∫°t Tutorial khi d√πng chi√™u E th√†nh c√¥ng
        if (this.inTutorial && this.tutorialSteps[this.tutorialIndex].condition === "skill_e") {
            this.advanceTutorial();
        }
    }
    useSkill(x, y) {
        if (this.isPaused) return; const self = this; const sid = this.sessionID;
        if (this.skillMode === 'RAIN') { 
            for(let i=0; i<6; i++) { setTimeout(() => { if (self.sessionID !== sid) return; const m = { tx: x+(Math.random()-0.5)*80, ty: y+(Math.random()-0.5)*80, x: x+150, y:-200, dead: false, update() { const dx = this.tx-this.x, dy = this.ty-this.y, d = Math.sqrt(dx*dx+dy*dy); if (d < 12) { this.dead = true; Sound.boom(); game.shake(12); game.enemies.forEach(e => { if (Math.sqrt((e.x-this.tx)**2+(e.y-this.ty)**2) < 90) e.takeDamage(400, 'magic'); }); game.effects.push({x:this.tx, y:this.ty, life:30, maxLife:30, color:'rgba(231, 76, 60, 0.8)', r:90}); } else { this.x += (dx/d)*15; this.y += (dy/d)*15; } }, draw(ctx) { ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.arc(this.x, this.y, 14, 0, Math.PI*2); ctx.fill(); } }; game.meteors.push(m); Sound.whistle(); }, i * 200); } 
            this.skillCDs.RAIN = CONFIG.SKILLS.RAIN.cd * 60; 
            if (this.inTutorial && this.tutorialSteps[this.tutorialIndex].condition === "combat") this.advanceTutorial();
        } 
        else if (this.skillMode === 'REINFORCE') { 
            Sound.horn(); const ft = { rallyX: x, rallyY: y }; this.militia.push(new Soldier(ft, 0, true)); this.militia.push(new Soldier(ft, 2, true)); this.skillCDs.REINFORCE = CONFIG.SKILLS.REINFORCE.cd * 60; 
            if (this.inTutorial && this.tutorialSteps[this.tutorialIndex].condition === "militia") this.advanceTutorial();
        }
        this.cancelActiveModes();
    }
    update() {
        if (this.isPaused) return; this.ticks++; if (this.waveTimer > 0) this.waveTimer--;
        // --- CH√àN V√ÄO ƒê√ÇY ---
        // C·∫≠p nh·∫≠t logic g√¢y s√°t th∆∞∆°ng c·ªßa v√πng ƒë·∫•t ch√°y
        this.fireAreas.forEach(fa => fa.update());
        // X√≥a c√°c v√πng ƒë√£ h·∫øt th·ªùi gian t·ªìn t·∫°i
        this.fireAreas = this.fireAreas.filter(fa => fa.life > 0);
        // --------------------

        this.enemies.forEach(e => e.update());
        if (this.shakeIntensity > 0) { this.shakeIntensity *= 0.9; if (this.shakeIntensity < 0.5) this.shakeIntensity = 0; }
        for (let s in this.skillCDs) { const lim = (s==='RAIN'?CONFIG.SKILLS.RAIN.cd:s==='HERO'?CONFIG.SKILLS.HERO_SLAM.cd:s==='REINFORCE'?CONFIG.SKILLS.REINFORCE.cd:1); if (this.skillCDs[s] > 0) { this.skillCDs[s]--; const el = document.getElementById(`cd-${s.toLowerCase()}`); if(el) el.style.height = (this.skillCDs[s]/(lim*60))*100+'%'; } else { const el = document.getElementById(`cd-${s.toLowerCase()}`); if(el) el.style.height = '0%'; } }
        this.enemies.forEach(e => e.update()); this.enemies = this.enemies.filter(e => { if(e.reached) { if (e.isBoss) this.lives -= 5; else this.lives--; } return !e.dead; });
        this.towers.forEach(t => t.update()); this.hero.update(); this.meteors.forEach(m => m.update()); this.meteors = this.meteors.filter(m => !m.dead); this.militia.forEach(s => s.update()); this.militia = this.militia.filter(s => !s.dead);
        this.projectiles.forEach((p) => { 
            if (!p.target || p.target.dead) {
            p.dead = true;
            return;
        }
            const dx = p.target.x - p.x, dy = p.target.y - p.y, d = Math.sqrt(dx*dx + dy*dy);
            if (d < 10) {
            if (p.type === 'bomb') { 
                const towerLv = p.towerLevel || 1;
                const sid = this.sessionID;

                // H√†m th·ª±c hi·ªán m·ªôt v·ª• n·ªï ƒë∆°n l·∫ª
                const executeExplosion = (ex, ey, isSub = false) => {
                    if (this.sessionID !== sid) return;

                    // Level 3 c√≥ b√°n k√≠nh n·ªï lan r·ªông h∆°n (100px), c√°c c·∫•p kh√°c 85px
                    const splashRadius = towerLv === 3 ? 100 : 85;
                    const dmgMult = isSub ? 0.5 : 1.0; 

                    this.enemies.forEach(e => { 
                        const dist = Math.sqrt((e.x - ex) ** 2 + (e.y - ey) ** 2);
                        if (dist < splashRadius) {
                            e.takeDamage(p.dmg * dmgMult, 'phys'); 
                        }
                    }); 

                    // Hi·ªáu ·ª©ng h√¨nh ·∫£nh n·ªï (M√†u s·∫Øc ƒë·∫≠m d·∫ßn theo level)
                    this.effects.push({
                        x: ex, y: ey, 
                        life: 15, maxLife: 15, 
                        color: towerLv === 3 ? '#e67e22' : 'orange', 
                        r: splashRadius - 20
                    }); 

                    // --- LOGIC HI·ªÜU ·ª®NG L·ª¨A (CH·ªà XU·∫§T HI·ªÜN T·ª™ LEVEL 2) ---
                    if (towerLv >= 2) {
                        // S√°t th∆∞∆°ng ƒë·ªët: Lv3 l√† 45, Lv2 l√† 30
                        const fireDmg = towerLv === 3 ? 45 : 30;
                        this.fireAreas.push(new FireArea(ex, ey, 60, isSub ? fireDmg/2 : fireDmg, 150));
                    }
                    
                    Sound.boom();
                    this.shake(isSub ? 5 : 10);
                };

                // 1. V·ª• n·ªï ch√≠nh (M·ªçi level ƒë·ªÅu c√≥)
                executeExplosion(p.x, p.y);

                // 2. Chu·ªói n·ªï ph·ª• "ƒê√πng ƒë√πng ƒë√πng" (CH·ªà D√ÄNH CHO LEVEL 3)
                if (towerLv === 3) {
                    for (let i = 1; i <= 3; i++) {
                        setTimeout(() => {
                            if (this.sessionID === sid && !this.isPaused) {
                                // C√°c v·ª• n·ªï ph·ª• xu·∫•t hi·ªán ng·∫´u nhi√™n quanh t√¢m
                                const offsetX = (Math.random() - 0.5) * 80;
                                const offsetY = (Math.random() - 0.5) * 80;
                                executeExplosion(p.x + offsetX, p.y + offsetY, true);
                            }
                        }, i * 200 / this.timeScale); // C√°ch nhau 0.2 gi√¢y
                    }
                }
            }
            else {
            if (p.type.includes('bolt')) {
                const towerLv = p.towerLevel; 
                // Thi·∫øt l·∫≠p b√°n k√≠nh gi·∫≠t ƒëi·ªán: Lv2 = 150px, Lv3 = 220px (C·ª±c r·ªông)
                const splashRadius = (towerLv === 3) ? 150 : (towerLv === 2 ? 100 : 60);
                const effectColor = p.type.includes('holy') ? '#f1c40f' : (towerLv === 3 ? '#ffffff' : (towerLv === 2 ? '#00d2ff' : '#bf00ff'));

                // S√°t th∆∞∆°ng m·ª•c ti√™u ch√≠nh
                p.target.takeDamage(p.dmg, 'magic', p.isCrit);

                // --- LOGIC GI·∫¨T ƒêI·ªÜN CHO LEVEL 2 & LEVEL 3 ---
                if (towerLv >= 2) {
                    let chainCount = 0;
                    // Lv3 gi·∫≠t t·ªëi ƒëa 3 m·ª•c ti√™u, Lv2 gi·∫≠t 2 m·ª•c ti√™u
                    const maxChain = (towerLv === 3) ? 3 : 2; // Gi·∫£m s·ªë m·ª•c ti√™u t·ªëi ƒëa

                    game.enemies.forEach(e => {
                        if (e !== p.target && !e.dead && chainCount < maxChain) {
                            const dist = Math.sqrt((e.x - p.x) ** 2 + (e.y - p.y) ** 2);
                            if (dist < splashRadius) {
                                chainCount++;
                                // S√°t th∆∞∆°ng gi·∫≠t ƒëi·ªán: Lv3 gi·ªØ 80% dmg, Lv2 gi·ªØ 70% dmg
                                const chainDmgMult = (towerLv === 3) ? 0.8 : 0.7;
                                e.takeDamage(p.dmg * chainDmgMult, 'magic', false);

                                // Hi·ªáu ·ª©ng tia s√©t (Lv3 s·∫Ω d√†y v√† s√°ng h∆°n)
                                game.effects.push({
                                    x: p.x, y: p.y, tx: e.x, ty: e.y,
                                    life: 15, maxLife: 15,
                                    lv: towerLv,
                                    draw(ctx) {
                                        ctx.save();
                                        ctx.strokeStyle = this.lv === 3 ? "#fff" : "#00d2ff";
                                        ctx.lineWidth = this.lv === 3 ? 3.5 : 2; // Lv3 tia s√©t to h∆°n
                                        // ctx.shadowBlur = this.lv === 3 ? 20 : 10;
                                        // ctx.shadowColor = this.lv === 3 ? "#bf00ff" : "#00d2ff";
                                        ctx.globalAlpha = this.life / this.maxLife;
                                        
                                        ctx.beginPath();
                                        ctx.moveTo(this.x, this.y);
                                        
                                        // TƒÉng s·ªë ƒëi·ªÉm g√£y ziczac cho Lv3 ƒë·ªÉ tia s√©t tr√¥ng h·ªón lo·∫°n h∆°n
                                        const steps = this.lv === 3 ? 3 : 2; 
                                        for(let j = 1; j < steps; j++) {
                                            const ratio = j / steps;
                                            const mx = this.x + (this.tx - this.x) * ratio + (Math.random() - 0.5) * 15;
                                            const my = this.y + (this.ty - this.y) * ratio + (Math.random() - 0.5) * 15;
                                            ctx.lineTo(mx, my);
                                        }
                                        
                                        ctx.lineTo(this.tx, this.ty);
                                        ctx.stroke();
                                        ctx.restore();
                                    }
                                });
                            }
                        }
                    });

                    // N·∫øu l√† Level 3, th√™m hi·ªáu ·ª©ng n·ªï ph√°o hoa nh·ªè t·∫°i c√°c ƒëi·ªÉm gi·∫≠t ƒëi·ªán ph·ª•
                    // if (towerLv === 3) {
                    //     for (let i = 0; i < 8; i++) {
                    //         const angle = (i / 8) * Math.PI * 2;
                    //         game.particles.push(new Particle(p.x, p.y, '#bf00ff', Math.cos(angle) * 5, Math.sin(angle) * 5, 20));
                    //     }
                    // }
                } else {
                    // --- LOGIC PH√ÅO HOA C≈® CHO LEVEL 1 ---
                    for (let i = 0; i < 6; i++) {
                        game.effects.push({
                            x: p.x, y: p.y,
                            angle: (i / 6) * Math.PI * 2 + (Math.random() * 0.4),
                            length: 60 * (0.5 + Math.random() * 0.5),
                            life: 15, maxLife: 15, color: '#bf00ff',
                            draw(ctx) {
                                ctx.save();
                                ctx.globalAlpha = this.life / this.maxLife;
                                ctx.strokeStyle = this.color; ctx.lineWidth = 2;
                                ctx.beginPath(); ctx.moveTo(this.x, this.y);
                                const currentLen = this.length * (1 - this.life / this.maxLife);
                                ctx.lineTo(this.x + Math.cos(this.angle) * currentLen, this.y + Math.sin(this.angle) * currentLen);
                                ctx.stroke(); ctx.restore();
                            }
                        });
                    }
                }
                
                Sound.fire();
            }else {
                // Logic cho m≈©i t√™n (Archer)
                p.target.takeDamage(p.dmg, 'phys', p.isCrit);
                
                // X·ª¨ L√ù HI·ªÜU ·ª®NG H·ªÜ BƒÇNG
                if (p.subType === 'ice') {
                    p.target.slowTimer = 120; // L√†m ch·∫≠m c∆° b·∫£n
                    
                    // N·∫æU L√Ä LEVEL 3: ƒê√ìNG BƒÇNG HO√ÄN TO√ÄN
                    if (p.towerLevel === 3) {
                        p.target.stunned = 60; // Qu√°i ƒë·ª©ng y√™n trong 1 gi√¢y (60 ticks)
                        
                        // Hi·ªáu ·ª©ng h√¨nh ·∫£nh t·∫£ng bƒÉng v·ª°
                        for (let i = 0; i < 6; i++) {
                            game.particles.push(new Particle(
                                p.target.x, p.target.y, 
                                '#dff9fb', 
                                (Math.random() - 0.5) * 4, 
                                (Math.random() - 0.5) * 4, 
                                20
                            ));
                        }
                    }
                }
    
                if (p.subType === 'fire') {
                    p.target.burnTimer = 180; // Hi·ªáu ·ª©ng ch√°y b√¨nh th∆∞·ªùng

                    // N·∫æU L√Ä LEVEL 3: C√ÄI BOM N·ªî CH·∫¨M
                    if (p.towerLevel === 3) {
                        // N·∫øu qu√°i ch∆∞a b·ªã c√†i bom, th√¨ c√†i bom 2 gi√¢y (120 ticks)
                        if (!p.target.bombTimer || p.target.bombTimer <= 0) {
                            p.target.bombTimer = 120; 
                            
                            // Hi·ªán ch·ªØ b√°o hi·ªáu cho ng∆∞·ªùi ch∆°i bi·∫øt
                            game.floatingTexts.push(new FloatingText(p.target.x, p.target.y - 30, "üî• H·ªéA BI·∫æN!", "#e67e22", 14, true));
                        }
                    }
                }
                }
            }
                    p.dead = true;
            } else { p.x += (dx/d)*p.speed*this.timeScale; p.y += (dy/d)*p.speed*this.timeScale; if (p.type === 'heavy_hoe') p.angle = (p.angle || 0) + 0.3 * this.timeScale; }
        });
        this.projectiles = this.projectiles.filter(p => !p.dead); this.floatingTexts = this.floatingTexts.filter(t => { t.update(); return t.life > 0; }); this.splats = this.splats.filter(s => { s.update(); return s.life > 0; }); this.particles = this.particles.filter(p => { p.update(); return p.life > 0; }); this.effects = this.effects.filter(e => { e.life--; return e.life > 0; });
        if (this.lives <= 0) { this.lives = 0; this.gameOver(false); return; } 
        if (this.waveIdx === this.waves.length && this.enemies.length === 0 && !this.spawning) this.gameOver(true);
        document.getElementById('gold-val').innerText = Math.floor(this.gold); document.getElementById('lives-val').innerText = this.lives; document.getElementById('wave-val').innerText = `${this.waveIdx}/12`;
        document.getElementById('hero-hp-bar').style.width = (this.hero.hp/this.hero.maxHp*100)+"%"; document.getElementById('hero-xp-bar').style.width = (this.hero.xp/this.hero.maxXp*100)+"%";
        document.getElementById('hero-lvl-text').innerText = "LV"+this.hero.lvl;
        if (!this.spawning && (this.enemies.length <= 3 || this.waveIdx === 0)) { const btn = document.getElementById('wave-btn'); btn.style.display = 'block'; const bonus = Math.floor(this.waveTimer / 60) * 2; document.getElementById('wave-bonus-text').innerText = (bonus > 0 && this.waveIdx < 12) ? `+${bonus} V√ÄNG` : ""; }
    }
    draw() {
        const ctx = this.ctx; ctx.clearRect(0,0,CONFIG.WIDTH,CONFIG.HEIGHT); ctx.save();
        if (this.shakeIntensity > 0) { const rx = (Math.random()-0.5)*this.shakeIntensity, ry = (Math.random()-0.5)*this.shakeIntensity; ctx.translate(rx, ry); }
        ctx.fillStyle = '#2ecc71'; ctx.fillRect(0,0,CONFIG.WIDTH,CONFIG.HEIGHT);
        this.splats.forEach(s => s.draw(ctx));
        ctx.strokeStyle = '#d35400'; ctx.lineWidth = 46; ctx.lineJoin = 'round'; ctx.lineCap = 'round'; ctx.beginPath(); MAP_PATH.forEach((p,i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)); ctx.stroke();
        ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 38; ctx.stroke();
        BUILD_PADS.forEach(pad => { ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.arc(pad.x, pad.y, 26, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#95a5a6'; ctx.lineWidth = 2; ctx.stroke(); });
        // V·∫Ω v√πng ƒë·∫•t ch√°y d∆∞·ªõi ch√¢n k·∫ª ƒë·ªãch
        this.fireAreas.forEach(fa => fa.draw(ctx));
        this.towers.forEach(t => t.draw(ctx)); this.enemies.forEach(e => e.draw(ctx)); this.hero.draw(ctx); this.militia.forEach(s => s.draw(ctx));
        this.projectiles.forEach(p => { 
            ctx.save(); ctx.translate(p.x, p.y);
            if (p.type === 'bolt') { const colors = ['#00d2ff', '#bf00ff', '#ffffff'];
                const color = colors[Math.floor(game.ticks / 2) % colors.length]; // ƒê·ªïi m√†u li√™n t·ª•c
                
                ctx.shadowBlur = 20; 
                ctx.shadowColor = color; 
                ctx.fillStyle = color; 
                
                // V·∫Ω qu·∫£ c·∫ßu ch√≠nh
                ctx.beginPath(); 
                ctx.arc(0, 0, 6 + Math.sin(game.ticks * 0.2) * 2, 0, Math.PI * 2); 
                ctx.fill();

                // V·∫Ω c√°c tia s√°ng ph√°o hoa nh·ªè xung quanh qu·∫£ c·∫ßu khi ƒëang bay
                for(let i=0; i<3; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 12;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle)*dist, Math.sin(angle)*dist, 1.5, 0, Math.PI*2);
                    ctx.fill();
                } 
            } 
            else if (p.type === 'heavy_hoe') { 
               // V·∫Ω hi·ªáu ·ª©ng v·ªát m·ªù khi xoay (Motion Blur Trail)
                ctx.save();
                ctx.globalAlpha = 0.3;
                for (let i = 1; i <= 3; i++) {
                    ctx.rotate(-0.15); // V·∫Ω c√°c b√≥ng ph√≠a sau h∆∞·ªõng xoay
                    ctx.fillStyle = '#bdc3c7';
                    ctx.beginPath();
                    ctx.arc(0, -6, 7, 0, Math.PI, true);
                    ctx.fill();
                }
                ctx.restore();

                // Xoay tr·ª•c ch√≠nh c·ªßa v≈© kh√≠
                ctx.rotate(p.angle);

                // --- V·∫º CHI·∫æC R√åU CH√ÇN TH·∫¨T ---
                // 1. C√°n r√¨u (G·ªó v√¢n t·ªëi)
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(-1.5, -10, 3, 22); 

                // 2. ƒê·∫ßu r√¨u (S·ªëng r√¨u d√†y)
                ctx.fillStyle = '#7f8c8d';
                ctx.fillRect(-3, -11, 6, 4); 

                // 3. L∆∞·ª°i r√¨u (H√¨nh b√°n nguy·ªát s·∫Øc b√©n)
                const grad = ctx.createLinearGradient(0, -10, 15, -10);
                grad.addColorStop(0, '#7f8c8d'); // M√†u th√©p ƒë·∫≠m ·ªü trong
                grad.addColorStop(1, '#ecf0f1'); // M√†u th√©p s√°ng ·ªü m≈©i l∆∞·ª°i
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                // V·∫Ω l∆∞·ª°i cong
                ctx.moveTo(2, -11);
                ctx.quadraticCurveTo(16, -11, 16, 0); // ƒê∆∞·ªùng cong m≈©i tr√™n
                ctx.quadraticCurveTo(16, 11, 2, 11);  // ƒê∆∞·ªùng cong m≈©i d∆∞·ªõi
                ctx.lineTo(2, 6);
                ctx.lineTo(2, -6);
                ctx.closePath();
                ctx.fill();

                // 4. ƒê∆∞·ªùng s·∫Øc c·∫°nh (Edge highlight)
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(2, 0, 11, -Math.PI / 2, Math.PI / 2, false);
                ctx.stroke();
            }
            else if (p.type.includes('ice')) { ctx.fillStyle = '#00d2ff'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); } 
            else if (p.type.includes('fire')) { ctx.fillStyle = '#ff7675'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); } 
            else { 
                if (p.type === 'bomb') {
                    // V·∫Ω bom c√≥ ng√≤i n·ªï
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill();
                    // Hi·ªáu ·ª©ng ph√°t s√°ng l√µi bom
                    ctx.shadowBlur = 10; ctx.shadowColor = 'red';
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath(); ctx.arc(-2, -2, 2, 0, Math.PI*2); ctx.fill();
                    // Ng√≤i n·ªï
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = '#f1c40f';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(5, -5); ctx.lineTo(10, -10); ctx.stroke();
                } else {
                    ctx.fillStyle = '#ecf0f1'; 
                    ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();
                }
            }
            ctx.restore();
        });
        this.meteors.forEach(m => { if(m.draw) m.draw(ctx); });
        this.effects.forEach(e => {
            if (e.draw) {
                e.draw(ctx); // V·∫Ω tia ƒëi·ªán ho·∫∑c tia ph√°o hoa
            } else {
                // V·∫Ω h√¨nh tr√≤n m·∫∑c ƒë·ªãnh cho c√°c hi·ªáu ·ª©ng kh√°c
                const r = Math.max(0, (e.r || 40) * (1 - e.life / (e.maxLife || 20)));
                ctx.fillStyle = e.color || 'rgba(255,160,0,0.5)';
                ctx.beginPath(); ctx.arc(e.x, e.y, r, 0, Math.PI*2); ctx.fill();
            }
        });
        this.particles.forEach(p => p.draw(ctx)); this.floatingTexts.forEach(t => t.draw(ctx));
        if (this.selectedTower) { ctx.beginPath(); ctx.arc(this.selectedTower.x, this.selectedTower.y, this.selectedTower.range, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fill(); ctx.strokeStyle = 'white'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]); }
        // --- DRAW CANVAS TUTORIAL ELEMENTS ---
        if (this.inTutorial) {
            const step = this.tutorialSteps[this.tutorialIndex];
            const arrowDom = document.getElementById('tutorial-arrow-dom');

            // Hi·ªÉn th·ªã menuArrow cho c·∫£ build-menu v√† upgrade-menu
            const menuOpen = document.getElementById('build-menu').style.display === 'block' || document.getElementById('upgrade-menu').style.display === 'block';
            if (step.menuArrow && menuOpen) {
                arrowDom.style.display = 'block';
                arrowDom.className = 'point-down';
                arrowDom.style.left = (this.selectedPad.x + step.menuArrow.x - 15) + 'px';
                arrowDom.style.top = (this.selectedPad.y + step.menuArrow.y - 30) + 'px';
            } else if (!step.arrow) {
                arrowDom.style.display = 'none';
            }

            if (step.groundArrow) {
                const bounce = Math.sin(this.ticks * 0.15) * 15;
                ctx.save(); ctx.translate(step.groundArrow.x, step.groundArrow.y + bounce);
                ctx.strokeStyle = "white"; ctx.lineWidth = 5; ctx.setLineDash([5,5]);
                ctx.beginPath(); ctx.arc(0,0, 60, 0, Math.PI*2); ctx.stroke();
                ctx.fillStyle = "#3498db"; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-20, -30); ctx.lineTo(20, -30); ctx.closePath(); ctx.fill();
                ctx.fillRect(-8, -60, 16, 40); ctx.restore();
            }
        }
        ctx.restore();
    }
    loop() { this.update(); this.draw(); requestAnimationFrame(() => this.loop()); }
   bindEvents() {
        window.addEventListener('mousedown', (e) => {
            if (this.isPaused || e.target.id !== 'gameCanvas') return;
            const rect = this.canvas.getBoundingClientRect(); const mx = (e.clientX-rect.left), my = (e.clientY-rect.top);
            if (this.skillMode) { this.useSkill(mx, my); return; }
            if (this.isHeroMoveMode) { 
                this.hero.targetX = mx; this.hero.targetY = my; Sound.heroMove(); this.hero.bark(this.hero.barksSelect[Math.floor(Math.random()*this.hero.barksSelect.length)]); 
                if (this.inTutorial && this.tutorialSteps[this.tutorialIndex].condition === "hero_move") this.advanceTutorial();
                this.cancelActiveModes(); return; 
            }
            if (this.isRallying && this.selectedTower) { 
                const t = this.selectedTower; const dx = mx - t.x, dy = my - t.y, d = Math.sqrt(dx*dx+dy*dy); 
                if(d>t.range){const a=Math.atan2(dy,dx);t.rallyX=t.x+Math.cos(a)*t.range;t.rallyY=t.y+Math.sin(a)*t.range;}else{t.rallyX=mx;t.rallyY=my;} 
                
                // --- TUTORIAL TRIGGER: Rally Click ---
                if (this.inTutorial && this.tutorialSteps[this.tutorialIndex].condition === "rally_click") this.advanceTutorial();
                
                this.cancelActiveModes(); Sound.heroMove(); return; 
            }
            const pad = BUILD_PADS.find(p => Math.sqrt((p.x-mx)**2+(p.y-my)**2)<32); 
            if(pad){
                // ƒê·∫£m b·∫£o selectedPad lu√¥n ƒë∆∞·ª£c c·∫≠p nh·∫≠t ƒë·ªÉ m≈©i t√™n ch·ªâ ƒë√∫ng v·ªã tr√≠ menu
                this.selectedPad = pad;
                const t=this.towers.find(t=>t.pad===pad); 
                if(t)this.showUpgradeMenu(t); 
                else {
                    this.showBuildMenu(pad);
                    if (this.inTutorial && pad === BUILD_PADS[0] && this.tutorialSteps[this.tutorialIndex].condition === "pad") this.advanceTutorial();
                    else if (this.inTutorial && pad === BUILD_PADS[1] && this.tutorialSteps[this.tutorialIndex].condition === "pad2") this.advanceTutorial();
                }
            } else this.hideMenus();
            if (Math.sqrt((mx-this.hero.x)**2+(my-this.hero.y)**2)<25 && !this.hero.isDead) { this.selectHeroMove(); }
        });
        window.addEventListener('keydown', (e) => { if (e.code === 'Space') { this.isPaused = !this.isPaused; document.getElementById('pause-indicator').style.display = this.isPaused ? 'block' : 'none'; return; } if (this.isPaused) return; if (e.code === 'KeyQ') this.selectSkill('RAIN'); if (e.code === 'KeyW') this.selectSkill('REINFORCE'); if (e.code === 'KeyE') this.useHeroSkill(); if (e.code === 'KeyR') this.selectHeroMove(); if (e.code === 'KeyS') this.nextWave(); if (e.code === 'Escape') this.cancelActiveModes(); });
    }
    showBuildMenu(pad) { if (this.isPaused) return; this.selectedPad = pad; const m = document.getElementById('build-menu'); m.style.display = 'block'; m.style.left = pad.x + 'px'; m.style.top = pad.y + 'px'; }
    showUpgradeMenu(t) { 
        if (this.isPaused) return;
        this.selectedTower = t; const m = document.getElementById('upgrade-menu'); m.style.display = 'block'; m.style.left = t.x + 'px'; m.style.top = t.y + 'px'; 
        document.getElementById('rally-btn').style.display = t.type === 'barracks' ? 'flex' : 'none'; 
        
        // --- TUTORIAL TRIGGER: Select Tower ---
        if (this.inTutorial && t.type === 'barracks' && this.tutorialSteps[this.tutorialIndex].condition === "select_barracks") this.advanceTutorial();

        const s1 = document.getElementById('upg-spec-1-btn'), s2 = document.getElementById('upg-spec-2-btn'), std = document.getElementById('upg-btn');
        const cost = t.level === 1 ? 150 : 200;
        if (t.type === 'archer' && t.level === 1) {
            std.style.display = 'none'; s1.style.display = 'flex'; s1.innerHTML = `‚ùÑÔ∏è<br>${cost}`; s2.style.display = 'flex'; s2.innerHTML = `üî•<br>${cost}`;
        } else if (t.type === 'barracks' && t.level === 2) {
            std.style.display = 'none'; s1.style.display = 'flex'; s1.innerHTML = `üõ°Ô∏è<br>${cost}`; s2.style.display = 'flex'; s2.innerHTML = `ü™ì<br>${cost}`;
        } else {
            std.style.display = 'flex'; s1.style.display = 'none'; s2.style.display = 'none';
            document.getElementById('upg-cost').innerText = t.level < 3 ? cost : "MAX";
            if (t.level >= 3) std.classList.add('disabled'); else std.classList.remove('disabled');
        }
        const type = t.type.toUpperCase(); let total = TOWER_DEFS[type].cost; if (this.selectedTower.level >= 2) total += 150; if (this.selectedTower.level === 3) total += 200;
        document.getElementById('sell-val').innerText = Math.floor(total * 0.7);
    }
    hideMenus() { document.getElementById('build-menu').style.display = 'none'; document.getElementById('upgrade-menu').style.display = 'none'; if(!this.isRallying) this.selectedTower = null; }
    startRally(e) { 
        if (this.isPaused) return; e.stopPropagation(); this.cancelActiveModes(); this.isRallying = true; document.getElementById('upgrade-menu').style.display = 'none'; document.getElementById('instruction-text').innerText = "CH·ªåN ƒêI·ªÇM T·∫¨P K·∫æT QU√ÇN"; document.getElementById('instruction-text').style.display = 'block'; document.getElementById('skill-cancel').style.display = 'flex'; 
        
        // --- TUTORIAL TRIGGER: Rally Button ---
        if (this.inTutorial && this.tutorialSteps[this.tutorialIndex].condition === "rally_btn") this.advanceTutorial();
    }
    buildTower(type) { 
        if (this.isPaused) return; 
        if (this.gold >= TOWER_DEFS[type].cost) { 
            this.gold -= TOWER_DEFS[type].cost; 
            this.towers.push(new Tower(this.selectedPad, type)); Sound.build(); this.hideMenus(); 
            if (this.inTutorial) {
                if (this.tutorialSteps[this.tutorialIndex].condition === "barracks" && type === "BARRACKS") this.advanceTutorial();
                else if (this.tutorialSteps[this.tutorialIndex].condition === "archer" && type === "ARCHER") this.advanceTutorial();
            }
        } 
    }
    upgradeTower(branch) { if (this.isPaused || !this.selectedTower) return; const cost = this.selectedTower.level === 1 ? 150 : 200; if (this.selectedTower.level < 3 && this.gold >= cost) { this.gold -= cost; this.selectedTower.upgrade(branch); Sound.upgrade(); this.hideMenus(); } }
    
    // --- UPDATED: sellTower to clean up stuck enemies ---
    sellTower() { 
        if (this.isPaused || !this.selectedTower) return;
        
        // Gi·∫£i ph√≥ng qu√°i v·∫≠t kh·ªèi binh l√≠nh c·ªßa th√°p b·ªã b√°n
        if (this.selectedTower.type === 'barracks') {
            this.selectedTower.soldiers.forEach(s => {
                if (s.target) {
                    const idx = s.target.blockers.indexOf(s);
                    if (idx > -1) s.target.blockers.splice(idx, 1);
                    s.target = null;
                }
            });
        }

        const type = this.selectedTower.type.toUpperCase();
        let total = TOWER_DEFS[type].cost; if (this.selectedTower.level >= 2) total += 150; if (this.selectedTower.level === 3) total += 200;
        this.gold += Math.floor(total * 0.7); 
        this.towers = this.towers.filter(t => t !== this.selectedTower); 
        this.hideMenus(); 
    }
    
    gameOver(win) { this.isPaused = true; const o = document.getElementById('msg-overlay'); o.style.display = 'flex'; document.getElementById('msg-title').innerText = win ? "CHI·∫æN TH·∫ÆNG!" : "TH·∫§T B·∫†I!"; }
}

class FireArea {
    constructor(x, y, radius, damage, duration) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.damage = damage; // S√°t th∆∞∆°ng m·ªói l·∫ßn ƒë·ªët
        this.life = duration;
        this.maxLife = duration;
    }
    update() {
        this.life--;
        // G√¢y s√°t th∆∞∆°ng cho qu√°i v·∫≠t ƒë·ª©ng trong v√πng l·ª≠a m·ªói 30 ticks (0.5 gi√¢y)
        if (this.life % 30 === 0) {
            game.enemies.forEach(e => {
                const dist = Math.sqrt((e.x - this.x) ** 2 + (e.y - this.y) ** 2);
                if (dist < this.radius) {
                    e.takeDamage(this.damage, 'magic');
                    e.burnTimer = 60; // Th√™m hi·ªáu ·ª©ng h√¨nh ·∫£nh ch√°y tr√™n ng∆∞·ªùi qu√°i
                }
            });
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.min(1, this.life / 20) * 0.5;
        // V·∫Ω v√πng ƒë·∫•t b·ªã nung ƒë·ªè
        const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
        grad.addColorStop(0, 'rgba(231, 76, 60, 0.8)');
        grad.addColorStop(1, 'rgba(231, 76, 60, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // V·∫Ω c√°c tia l·ª≠a nh·ªè n·∫£y l√™n t·ª´ m·∫∑t ƒë·∫•t
        if (Math.random() < 0.3) {
            game.particles.push(new Particle(
                this.x + (Math.random() - 0.5) * this.radius,
                this.y + (Math.random() - 0.5) * this.radius,
                '#f1c40f', (Math.random() - 0.5), -Math.random() * 2, 20
            ));
        }
        ctx.restore();
    }
}


const game = new Game(); game.loop();
</script>
</body>
</html>